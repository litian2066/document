1.启动QuorumPeerMain类的main方法
2.读取配置文件到类QuorumPeerConfig config = new QuorumPeerConfig();中
3.解析配置类，包括很多属性，以及判断是否有集群的配置，如果有进一步将server和observer一些属性进行解析
	1.集群模式下还会加载一个集群验证的类，主要是过半机制
4.打开nioSocket
5.将集群服务器个数以及一些配置信息加载到quorumPeer类里面
6.quorumPeer.start()
	1.加载数据 从zkDb拿到快照导出数据到内存DataTree 
		ZkDb -> DataTree -> DataNode(节点)
		1.从快照中反序列化到DataTree里面
		2.从快照中还原数据库时，快照很可能落后于事务日志，所以需要从落后的那一部分事务日志中更新内存
	2.领导者选举	
	3.启动线程，执行run()方法

		1.while(running)无线循环判断服务器角色，在对应角色执行对应方法，Switch
			1.LOOKING: 还在选举中
			2.OBSERVER: 观察者
				 startUp()
				 	ObserverRequestProcessor.next = CommitProcessor.next = FinalRequestProcessor	
			3.FOLLOWING: 跟随者
				1.找到leader
				2.发送socket请求连接leader
				3.注册到leader 返回第几届
					1.构造packet
					2.写数据
				4.接受leader发过来的LEADERINFO，然后构造packet，发送ack
				5.数据同步 syncWithLeader
					1.LEADER.DIFF：上面都不做 下面代码处理
					2.LEADER.SNAP:处理快照
					3.LEADER.TARUNC:删数据
					4.while循环处理，判断服务器一直在running的话，下面是case 从这儿就读取LEADER.DIFF的里面的commit请求，将日志放在一个队列里面，那么时候退出这个循环呢？ 当case = updatetodate就跳出循环，需要leader发送这个过来就好，开始是leader发送一个newleader的ack过来，然后follower返回一个ack，接着leader发送一个updatetodate的ack过来，这会儿就退出while循环，接着执行COMMIT的队列信息
				6.startUp()
					FollowerRequestProcessor.next = CommitProcessor.next = FinalRequestProcessor
					如果客户端发送事务请求就发送给leader，leader在REQUEST下接收然后按leader的请求调用链处理
					同时会单独执行SyncRequestProcessor.next = SendAckRequestProcessor
					1.接受到leander的提议，直接持久化，如果成功就返回ack
					2.接受到leader的commit
					3.更新内存 	
			4.LEADING: 领导者	
				1.zk.loadData(); 还去加载数据，有点不懂
				2.启动线程Leader待Follwer连接
					1.等待Socket连接   Socket s = ss.accept();
					2.除开Leader服务器，其他服务器都会与Leader建立连接，这个时候都会新建出一个LearnerHandler线程然后启动线程
						LearnerHandler fh = new LearnerHandler(s, is, Leader.this);
						1.从流中读取数据
						2.this.sid = sid follower传过来的sid
						3.选取Epoch最大的Follower 然后+1， 生成这一届的序号，其实就是新一届代表，zxid即事务id里面低32位里面需要用到Epoch
							1.如果follower比较多的话也不会无止境的选取Epoch，接下来会去验证过半机制，只要过半就把这个follower的Epoch + 1返回，如果不满足就等待（阻塞）
						4.构造Packet  QuorumPacket newEpochPacket = new QuorumPacket(Leader.LEADERINFO, ZxidUtils.makeZxid(newEpoch, 0), ver, null);  发送leader状态,以LEADERINFO的形式
						5.数据同步
							分析：同步应该是通过快照来进行的，但是快照不一定是最新的，那怎么办呢？
							在单机版中请求链中SyncProcess是处理持久化事务的，而最后的FinalProcesors会存储最大的事务id，committedLog存储已经提交了持久化好了的request，所以比快照更新的数据就在这个committedLog里面，存储了zxid
								1.如果follower的zxid和当前的leader的一样不做太多的处理
								2.LEADER.DIFF:如果follower的zxid小于leader的zxid的话，这个叫找出它们之间缺少的部分，然后循环把数据放入一个QueuePacket的队列里面，然后构造一个commit请求，然后也加入队列
								3.LEADER.TRUNC:如果follower发过来的zxid大于leader的zxid, 找出大于的部分让follower回滚 后面也是加入队列
								4.LEADER.SNAP:如果follower小于leader的zxid最小的，就使用快照
								6.处理完以上部分 把快照序列化通过socket写出去，然后new 一个 Thread发送上面队列的请求 		
				3.startZKserver() -> startUp（）-> setupRequestProcessors();
					1.简单来说就是初始化请求链: 集群模式下在LeaderZooKeeperServer类里面
						firstProcessor = PrepRequestProcessor.next = proposalProcessor.next【】 = commitProcessor.next = toBeAppliedProcessor.next = finalProcessor
						但是syncProcessor也是在用的，中间也有个方法执行	
					2.PrepRequestProcessor:checkACL, 构造ack
						syncProcessor：持久化事务，日志
						finalProcessor： 更新内存，返回response	
						proposalProcessor： 
							1.调用commitProcessor进行阻塞
								1.可以提交的调用下一个processors处理
								2.不可以立马提交的就阻塞，主要是等待提议结果
							2.发起提议
							3.持久化
					3.判断多少台follower返回的ack，过半机制判断，然后发送提交请求		
					4.更新内存

7.quorumPeer.join()