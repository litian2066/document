# 分布式锁

模拟多线程环境下创建订单减库存

Order

````java
/**
 * 订单系统
 */
public class Order {

    public void createOrder() {
        System.out.println(Thread.currentThread().getName() + "创建订单");
    }
}
````

Stock

````java
/**
 * 库存
 */
public class Stock {

    public static Integer COUNT = 1;
	
    // 减库存
    public boolean reduceStock() {
        if (COUNT > 0) {
            COUNT--;
            return true;
        }
        return false;
    }
}
````

Pay

````java
// 支付
public class Pay {

    public void pay() {
        System.out.println(Thread.currentThread().getName() + "支付成功");
    }
}
````

测试类

````java
// 测试
public class Main {

    public static void main(String[] args) {
        Thread thread1 = new Thread(new UserThread(), "user1");
        Thread thread2 = new Thread(new UserThread(), "user2");

        thread1.start();
        thread2.start();
    }
    // 模拟下单的人
    static class UserThread implements Runnable {

        @Override
        public void run() {
            new Order().createOrder();
            boolean result = new Stock().reduceStock();
            if (result) {
                System.out.println(Thread.currentThread().getName() + "减库存成功");
                new Pay().pay();
            } else {
                System.out.println(Thread.currentThread().getName() + "减库存失败");
            }
        }
    }
}
````

结果：

````java
user2创建订单
user1创建订单
user2减库存成功
user1减库存成功
user2支付成功
user1支付成功
````

由上可知，多线程环境下很容易出问题，于是我们可以尝试去加锁

```java
public class Main {

    public static void main(String[] args) {
        Thread thread1 = new Thread(new UserThread(), "user1");
        Thread thread2 = new Thread(new UserThread(), "user2");

        thread1.start();
        thread2.start();
    }
	// 使用可重入锁
    static Lock lock = new ReentrantLock();

    // 模拟下单的人
    static class UserThread implements Runnable {

        @Override
        public void run() {
            new Order().createOrder();
            lock.lock();
            boolean result = new Stock().reduceStock();
            lock.unlock();
            if (result) {
                System.out.println(Thread.currentThread().getName() + "减库存成功");
                new Pay().pay();
            } else {
                System.out.println(Thread.currentThread().getName() + "减库存失败");
            }
        }
    }
}
```

````java
user1创建订单
user2创建订单
user1减库存成功
user2减库存失败
user1支付成功
````

但是在分布式环境下，服务是部署在好几台机器上，这种加锁方式并不可用，于是我们可以利用`ZooKeeper`创建分布式环境下的锁，控制用户访问。

创建一个类`zkLock`可以替换`ReentrantLock`

分析分布式锁：

1. 永远只有一个人获得，所以具有唯一性，可以使用zk的顺序节点
2. 释放锁的时候可以将节点删掉即可，为了防止系统挂掉，节点不删除，所以可以使用临时节点，通过`ZooKeeper`的心跳机制自动删除
3. 所以总结下来，我们使用zk创建分布式锁可以通过**临时顺序节点**
4. 但是节点删除后我们怎么告知下一个系统获取分布式锁？使用while不停循环比较耗费性能，我们可以通过`Zookeeper`的`watcher`机制，**让后一节点监听前一个节点**。

![1569391431421](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1569391431421.png)

代码实现：

````java
import org.apache.zookeeper.*;
import org.apache.zookeeper.data.Stat;

import java.io.IOException;
import java.util.Collections;
import java.util.List;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Lock;

/**
 *  分布式锁
 *  使用原生客户端实现
 */
public class ZkLock implements Lock {
    // 使用ThreadLocal保证线程安全
    private ThreadLocal<ZooKeeper> zk = new ThreadLocal<>();

    private String LOCK_NAME = "/LOCK";

    private ThreadLocal<String>  CURRENT_NODE = new ThreadLocal<>();

    public void init() {
        if (zk.get() == null) {
            try {
                zk.set(new ZooKeeper("localhost:2181", 300, new Watcher() {
                    @Override
                    public void process(WatchedEvent event) {
                        // TODO
                    }
                }));

                Stat exists = zk.get().exists(LOCK_NAME, false);
                if (exists == null) {
                    CURRENT_NODE.set(zk.get().create(LOCK_NAME, new byte[0], ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT));
                }
            } catch (IOException e) {
                e.printStackTrace();
            } catch (InterruptedException e) {
                e.printStackTrace();
            } catch (KeeperException e) {
                e.printStackTrace();
            }
        }
    }

    public void lock() {
        init();
        if (tryLock()) {
            System.out.println(Thread.currentThread().getName() + "已经获取到锁了");
        }
    }

    @Override
    public void lockInterruptibly() throws InterruptedException {

    }

    /**
     * 尝试获取锁，
     * 如果没有获取到锁就阻塞等待获取到锁
     * @return
     */
    public boolean tryLock() {
        String nodeName = LOCK_NAME + "/zk_";
        try {
            // 创建临时顺序节点
            CURRENT_NODE.set(zk.get().create(nodeName, new byte[0], ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL_SEQUENTIAL));
            // 查找父节点下面的子节点
            List<String> list = zk.get().getChildren(LOCK_NAME, false); // zk_1, zk_2
            // 排序
            Collections.sort(list);
            // 找到最小的
            String minNodeName = list.get(0);
            // 判断当前节点是不是第一个节点，如果是第一个就获取到锁
            if (CURRENT_NODE.equals(LOCK_NAME + "/" + minNodeName) ) {
                return true;
            } else {
                // 如果不是就监听前面一个节点，如果前面节点没有被删除就阻塞
                // 获取当前节点的索引
                String currentNodeSimpleName = CURRENT_NODE.get().substring(CURRENT_NODE.get().lastIndexOf("/"));
                int currentNodeIndex = list.indexOf(currentNodeSimpleName);
                String prevNodeName = list.get(currentNodeIndex - 1);

                CountDownLatch countDownLatch = new CountDownLatch(1);

                // 判断节点是否存在,并添加监听
                zk.get().exists(LOCK_NAME + "/" + prevNodeName, new Watcher() {
                    @Override
                    public void process(WatchedEvent event) {
                        // 没有触发就阻塞
                        if (Event.EventType.NodeDeleted.equals(event.getType())) {
                            countDownLatch.countDown();
                            System.out.println(Thread.currentThread().getName() + "被唤醒了....");
                        }
                    }
                });

                System.out.println(Thread.currentThread().getName() + "阻塞住....");
                countDownLatch.await();
                return true;
            }
        } catch (KeeperException e) {
            e.printStackTrace();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        return false;
    }

    @Override
    public boolean tryLock(long time, TimeUnit unit) throws InterruptedException {
        return false;
    }

    // 解锁，手动删除临时节点，比session失效快
    public void unlock() {
        // 传入-1,忽略版本控制
        try {
            zk.get().delete(CURRENT_NODE.get(), -1);
            CURRENT_NODE.set(null);
            zk.get().close(); // 关掉zk
        } catch (InterruptedException e) {
            e.printStackTrace();
        } catch (KeeperException e) {
            e.printStackTrace();
        }
    }

    @Override
    public Condition newCondition() {
        return null;
    }
}
````

其实上面使用的代码并不完整，在真实的业务场景下显然没有这么简单，**Zookeeper分布式锁也可以使用curator客户端实现**

````java
/**
 * 分布式锁
 */
@Slf4j
@Component
public class DistributedLock {

    @Autowired
    private CuratorFramework client;
    // 用于挂起当前请求, 并且等待上一个分布式锁释放
    private static CountDownLatch zkLockLatch = new CountDownLatch(1);
    // 分布式锁的总结点名
    private static final String ZK_LOCK_PROJECT = "zk_locks";
    // 分布式锁节点
    private static final  String DISTRIBUTED_LOCK = "distributed_lock";

    /**
     * 初始化锁
     */
    @PostConstruct
    public void init() {
        client = client.usingNamespace("ZKLocks-Namespace");
        /**
         *  创建zk锁的总节点, 相当于eclipse的工作空间下的项目
         *      ZKLocks-Namespace
         *          |
         *          ---imooc-locks
         *                 |
         *                 ----distributed_lock
         */
        try {
            if (client.checkExists().forPath("/" + ZK_LOCK_PROJECT) == null) {
                client.create()
                        .creatingParentsIfNeeded()
                        .withMode(CreateMode.EPHEMERAL)
                        .withACL(ZooDefs.Ids.OPEN_ACL_UNSAFE)
                        .forPath("/" + ZK_LOCK_PROJECT);
                // 针对zk的分布式锁节点, 创建相应的watcher事件
                addWatcherToLock("/" + ZK_LOCK_PROJECT);
            }
        } catch (Exception e) {
            log.error("客户端连接zookeeper服务器错误: {}" + e.getMessage());
        }

    }

    /**
     * 添加watcher监听
     * @param path
     */
    private void addWatcherToLock(String path) throws Exception {
        final PathChildrenCache cache = new PathChildrenCache(client, path, true);
        cache.start(PathChildrenCache.StartMode.POST_INITIALIZED_EVENT);
        cache.getListenable().addListener(new PathChildrenCacheListener() {
            @Override
            public void childEvent(CuratorFramework client, PathChildrenCacheEvent event) throws Exception {
                if (event.getType().equals(PathChildrenCacheEvent.Type.CHILD_REMOVED)) {
                    String path = event.getData().getPath();
                    log.info("上个会话已经释放锁或该会话已经断开, 节点路径为: " + path);
                    if (path.contains(DISTRIBUTED_LOCK)) {
                        log.info("释放计数器, 让当前请求来获得分布式锁");
                        zkLockLatch.countDown();
                    }

                }
            }
        });
    }

    /**
     * 获取分布式锁
     */
    public void getLock() {
        // 使用死循环,当且仅当上一个锁释放完并且当前请求获得锁后才会跳出
        while (true) {
            try {
                client.create()
                        .creatingParentsIfNeeded()
                        .withMode(CreateMode.EPHEMERAL)
                        .withACL(ZooDefs.Ids.OPEN_ACL_UNSAFE)
                        .forPath("/" + ZK_LOCK_PROJECT + "/" + DISTRIBUTED_LOCK);
                log.info("获得分布式锁成功...");
                return;
            } catch (Exception e) {
                log.info("获得分布式锁失败, 失败原因: {}" + e.getMessage());
                try {
                    // 如果没有获得锁, 需要重新设置同步资源值
                    if (zkLockLatch.getCount() <= 0) {
                        zkLockLatch = new CountDownLatch(1);
                    }
                    // 阻塞线程
                    zkLockLatch.await();
                } catch (InterruptedException ex) {
                    ex.printStackTrace();
                }
            }
        }
    }

    /**
     * 释放分布式锁
     * @return
     */
    public boolean releaseLock() {
        try {
            if (client.checkExists().forPath("/" + ZK_LOCK_PROJECT + "/" + DISTRIBUTED_LOCK) != null) {
                client.delete().forPath("/" + ZK_LOCK_PROJECT + "/" + DISTRIBUTED_LOCK);
            }
        } catch (Exception e) {
            e.printStackTrace();
            return false;
        }
        log.info("分布式锁释放完毕");
        return true;
    }

}

````



# 分布式配置中心

分布式环境下，如果修改某个的配置，那么就需要一台一台的改，如果有一个配置中心呢？

![1569398034738](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1569398034738.png)

如图，我们只需要修改配置中心的某个配置就可以完成绑定的服务器的配置了。

**代码实现：**

````java
package com.document.distributed.config;

import org.apache.curator.framework.CuratorFramework;
import org.apache.curator.framework.CuratorFrameworkFactory;
import org.apache.curator.framework.recipes.cache.PathChildrenCache;
import org.apache.curator.framework.recipes.cache.PathChildrenCacheEvent;
import org.apache.curator.framework.recipes.cache.PathChildrenCacheListener;
import org.apache.curator.retry.RetryNTimes;
import org.apache.zookeeper.CreateMode;
import org.apache.zookeeper.data.Stat;

import java.util.HashMap;
import java.util.List;
import java.util.Map;

/**
 * 使用Curator生成Zookeeper配置中心
 * 通过watch机制来更新缓存
 */
public class Config {
    // 本地缓存，不可能每次都从zk里面拿数据，比较消耗性能，所以使用缓存
    private Map<String, String> cache = new HashMap<>();

    private CuratorFramework client;
    
    private static final String CONFIG_PREFIX = "/CONFIG";

    public Config() {
        RetryNTimes retryNTimes = new RetryNTimes(3, 1000);
        /*this.client = CuratorFrameworkFactory
                .builder()
                .build()
                .usingNamespace(CONFIG_PREFIX)
                .*/
        this.client =
                CuratorFrameworkFactory.newClient("localhost:2181", retryNTimes);
        client.start();
        init();
    }

    // 从配置中心把配置项缓存到本地
    public void init() {
        try {
            List<String> list = client.getChildren().forPath(CONFIG_PREFIX);
            for (int i = 0; i < list.size(); i++) {
               String name = list.get(i);   // 拿到子节点名字
               String value = new String(client.getData().forPath(CONFIG_PREFIX + "/" +name));
               cache.put(name, value);
            }
            // 绑定一个监听器，监听CONFIG_PREFIX下面的孩子节点的增删改事件，然后对应的去修改缓存Map中的数据
            PathChildrenCache watch = new PathChildrenCache(client, CONFIG_PREFIX, true);
            watch.getListenable().addListener(new PathChildrenCacheListener() {
                @Override
                public void childEvent(CuratorFramework client, PathChildrenCacheEvent event) throws Exception {
                    // 全路径
                    String path = event.getData().getPath();
                    if (path.startsWith(CONFIG_PREFIX)) {
                        String key = path.replace(CONFIG_PREFIX + "/", "");
                        if (event.getType().equals(PathChildrenCacheEvent.Type.CHILD_ADDED)
                                || event.getType().equals(PathChildrenCacheEvent.Type.CHILD_UPDATED)) {
                            // 子节点增加事件以及修改
                            cache.put(key, new String(event.getData().getData()));
                        } else if (event.getType().equals(PathChildrenCacheEvent.Type.CHILD_REMOVED)) {
                            // 子节点删除事件
                            cache.remove(key);
                        }
                    }

                }
            });
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    // 新增配置或者更新配置
    public void save(String name, String value) {
        try {
            String configFullName = CONFIG_PREFIX + "/" + name;
            Stat stat = client.checkExists().forPath(configFullName);
            if (stat == null) {
                // 配置项不存在
                client.create()
                        .creatingParentsIfNeeded()
                        .withMode(CreateMode.PERSISTENT)
                        .forPath(configFullName, value.getBytes());
            } else {
                client.setData().forPath(configFullName, value.getBytes());
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    public String get(String name) {
        return cache.get(name);
    }
}

````

测试类，简单测试一下：

````java
import java.util.concurrent.TimeUnit;

public class App {

    public static void main(String[] args) {
        Config config = new Config();
        config.save("timeout", "100");

        for (int i = 0; i < 100; i++) {
            String time = config.get("time");
            try {
                TimeUnit.SECONDS.sleep(5);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }
}
````

# Zookeeper客户端

顺便提一下，使用`ZooInspector`就可以图形化界面操作`Zookeeper`上面的节点，下下来，运行jar就行了。

