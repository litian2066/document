# 分布式事务

在分布式项目里面两个不同的服务，如果他们刚好在同一个事务里面，那么出现异常或者其他问题可能导致事务不一致，比如A服务调用B服务的接口，A服务持久化数据到数据库，B服务也持久化数据到数据库，如果A服务出现异常导致A不能持久化数据到数据库，而此时B服务却把数据持久化到了数据库，这个问题就很严重。

所以我们要使用分布式事务，这儿实现的是一种手写的分布式事务方案。

例子：

我们先搭建两个项目`px-server1`和`px-server2`

+ `pom`

  ```xml
  <dependency>
      <groupId>org.springframework.boot</groupId>
      <artifactId>spring-boot-starter-web</artifactId>
  </dependency>
  
  <dependency>
      <groupId>org.springframework.boot</groupId>
      <artifactId>spring-boot-starter-test</artifactId>
      <scope>test</scope>
      <exclusions>
          <exclusion>
              <groupId>org.junit.vintage</groupId>
              <artifactId>junit-vintage-engine</artifactId>
          </exclusion>
      </exclusions>
  </dependency>
  
  <dependency>
      <groupId>org.mybatis.spring.boot</groupId>
      <artifactId>mybatis-spring-boot-starter</artifactId>
      <version>1.3.2</version>
  </dependency>
  
  
  <dependency>
      <groupId>mysql</groupId>
      <artifactId>mysql-connector-java</artifactId>
      <version>5.1.44</version>
  </dependency>
  ```

+ `px-server1`

  + `application.properties`

    ````properties
    spring.datasource.driverClassName = com.mysql.jdbc.Driver
    spring.datasource.url = jdbc:mysql://localhost:3306/InnoDB?useUnicode=true&characterEncoding=utf-8&useSSL=false
    spring.datasource.username = root
    spring.datasource.password = root
    
    mybatis.type-aliases-package=com.px.server
    mybatis.mapper-locations=classpath:*.xml
    
    server.port=8081
    ````

    

  + `controller`

    ```java
    @RestController
    @RequestMapping("server1")
    public class DemoController {
    
        @Autowired
        private DemoService demoService;
    
        @GetMapping(value = "test")
        public R test() {
            return demoService.test();
        }
    }
    ```

  + `serverice`

    ```java
    @Service
    public class DemoService {
    
        @Autowired
        private Demodao demoDao;
    
        @Autowired
        private RestTemplate restTemplate;
    
        @Transactional
        public R test() {
            demoDao.insert("server1");
            // HttpUtil.post("http://localhost:8082/server2/test");
            Object o = restTemplate.postForObject("http://localhost:8082/server2/test", null, Object.class);
            int i = 1/0; // 模拟错误
            return R.success("", o);
        }
    }
    ```

  + `dao`

    ```java
    @Mapper
    public interface Demodao {
    
        @Insert("insert into t_test(name) values(#{name})")
        public void insert(@Param("name") String name);
    
    }
    ```

  + `config`

  + ```java
    @Configuration
    public class Config {
    
        @Bean
        public RestTemplate restTemplate() {
            return new RestTemplate();
        }
    }
    ```

    ```java
    public class R extends HashMap {
        public static String SUCCESS_CODE = "200";
        public static String ERROR_CODE = "500";
        public static String DATA_KEY = "data";
        public static String MSG_KEY = "msg";
    
        private R() {
    
        }
    
        public R set(String key, Object object) {
            super.put(key, object);
            return this;
        }
    
        private static R ok() {
            return new R();
        }
    
        public static R success() {
    
            return R.ok().set("code", R.SUCCESS_CODE).set(R.MSG_KEY, "操作成功");
        }
    
        public static R success(String msg) {
    
            return R.ok().set("code", R.SUCCESS_CODE).set(R.MSG_KEY, msg);
        }
    
        public static R success(String msg, Object object) {
    
            return R.ok().set("code", R.SUCCESS_CODE).set(R.MSG_KEY, msg).set(R.DATA_KEY, object);
        }
    
        public R data(Object obj) {
            return this.set("data", obj);
        }
    
        public static R error() {
            return R.ok().set(R.MSG_KEY, "操作失败").set("code", R.ERROR_CODE);
        }
    
        public static R error(String msg) {
            return R.ok().set(R.MSG_KEY, msg).set("code", R.ERROR_CODE);
        }
    
        public static R error(String msg, Object object) {
            return R.ok().set(R.MSG_KEY, msg).set(R.DATA_KEY, object).set("code", R.ERROR_CODE);
        }
    
    }
    ```

+ `px-server2`

  + `application.properties`

    ```properties
    spring.datasource.driverClassName = com.mysql.jdbc.Driver
    spring.datasource.url = jdbc:mysql://localhost:3306/InnoDB?useUnicode=true&characterEncoding=utf-8&useSSL=false
    spring.datasource.username = root
    spring.datasource.password = root
    
    mybatis.type-aliases-package=com.px.server
    mybatis.mapper-locations=classpath:*.xml
    
    server.port=8082
    ```

  + `controller`

    ```java
    @RestController
    @RequestMapping("server2")
    public class DemoController {
    
        @Autowired
        private DemoService demoService;
    
        @PostMapping(value = "test")
        public void test() {
            demoService.test();
        }
    }
    ```

  + `service`

    ```java
    @Service
    public class DemoService {
        
        @Autowired
        private DemoDao demoDao;
    
    //    @LbTransactional(isEnd = true)
        @Transactional
        public void test() {
            demoDao.insert("server2");
        }
    }
    ```

  + `dao`

    ```java
    @Mapper
    public interface DemoDao {
    
        @Insert("insert into t_test(name) values(#{name})")
        public void insert(@Param("name") String name);
    }
    ```

  通过上面两个项目模拟，发现server2的数据能插入进去，而server1的项目却插不进去。

## 解决思路

**单机下有如下操作：**

1. 拿到连接
2. 开启事务
3. 执行业务逻辑
4. 提交/回滚
5. 关闭连接

假设有两个服务：

分析：

1. 因为两个微服务是不同的进程，使用原生的思路不能解决，因为不知道在那个地方开启事务，回滚事务，所以我们提出一个**事务管理者**的概念来管理事务。
2. 

## 2PC方式

### 分析：

假设有两个微服务：订单微服务和库存微服务，因为他们是两个独立的进程，使用原生的思路不能解决，因为不知道在那个地方开启事务，回滚事务，所以需要一个**事务管理者**来管理事务，同时将订单微服务和库存微服务的事务放在一个抽象概念**事务组**里面进行管理，所以有如下步骤：

1. 事务由订单开始（start请求）， 由库存服务结束（end请求）
2. 订单微服务执行业务逻辑
3. 库存微服务执行业务逻辑
4. 订单微服务和库存微服务发送**可以提交了**给事务管理者
5. 事务管理者判断是否可以提交以及回滚（**只要事务组里面有一个事务不是可以提交的状态，那么就都回滚**）
6. 事务管理者接受到end请求判断是否可以提交和回滚
7. 事务管理者发送通知给订单微服务和库存微服务
8. 订单微服务和库存微服务执行提交或者回滚操作

### 代码实现

那么spring有@Transactional的注解开启声明式事务，那么我们也可以定义一个注解来开启分布式事务

新建一个模块`px-transaction`作为公共模块

创建注解：

```java
/**
 * 自定义分布式事务注解
 */
@Target(ElementType.METHOD)
@Retention(RetentionPolicy.RUNTIME)
public @interface MyTransaction {
    // 发起事务
    boolean isStart() default false;
    // 事务结束
    boolean isEnd() default false;
}
```

**我们要控制分布式事务，那我们需要拿到本地事务**，那么要怎么拿到本地事务？其实spring开启事务也是通过`DataSource`拿到connection然后执行业务逻辑，最后commit（本地事务那一套），所以我们设计就是要让commit挂起，处理我们的逻辑后再commit。那么我们怎么从spring手上拿到事务控制权？所以我们要在spring拿到连接起就开始控制。

1. spring也是通过datasource的getConnection()方法拿到连接，所以我们需要将这个Connection对象代理，返回我们自己定义的Connection对象。

2. 自定义connection对象，这儿只截取一部分，还有很多需要实现的方法。

   ```java
   /**
    * 自定义连接，将自己封装的connection给spring
    * 因为spring底层也是通过dataSource来拿到connection对象
    */
   public class MyConnection implements Connection {
   
       // Spring实现的connection
       private Connection connection;
   
       public MyConnection(Connection connection) {
           this.connection = connection;
       }
   
   
       @Override
       public void commit() throws SQLException {
           // 我们自己的逻辑
   
           // 然后提交
           this.connection.commit();
       }
   
       @Override
       public void rollback() throws SQLException {
           this.connection.rollback();
       }
   
       @Override
       public void close() throws SQLException {
           this.connection.close();
       }
   }
   ```

3. 怎么把我们自己的Connection交给Spring管理呢？**通过代理就可以了，这儿通过AOP方式实现。**

   ```java
   // 配置连接切面，截取spring获取的DataSource连接，然后返回我们自定义的连接对象
   @Aspect
   @Component
   public class ConnectionAspect {
   
       // 代理Datasource的connection
       @Around("execution(* javax.sql.DataSource.getConnection(..))")
       public Connection around(ProceedingJoinPoint proceedingJoinPoint) {
           try {
               // 拿到spring的connection对象
               Connection connection = (Connection) proceedingJoinPoint.proceed();
               // 最终spring的connection对象是我们自己的connection对象
               return new MyConnection(connection);
           } catch (Throwable throwable) {
               throwable.printStackTrace();
           }
           return null;
       }
   
   }
   ```

4. 事务管理者是通过Netty发送请求的，所以我们的事务管理者是一个netty的服务端，最后会把代码贴出来。

5. 怎么把本地事务和事务管理者的事务结合起来呢？肯定本地也要和netty通信，我们之前添加了`@MyTransaction`注解，所以我们可以再写一个切面来代理：

   ```java
   @Aspect
   @Component
   public class TransactionAspect {
   
       @Around("@annotation(com.px.annotation.MyTransaction)")
       public void invoke(ProceedingJoinPoint proceedingJoinPoint) {
           // 首先拿到方法对象
           MethodSignature signature = (MethodSignature) proceedingJoinPoint.getSignature();
           // 拿到我们的注解对象
           MyTransaction annotation = signature.getMethod().getAnnotation(MyTransaction.class);
           if (annotation.isStart()) {
               // 创建事务组
           } else {
               // 拿到当前事务组的id
   
           }
       }
   }
   ```

   写到这儿，我们发现需要创建事务组，要发送请求，那么我们可以把对事务的操作封装成几个类：

   事务类：`Transaction`

   ```java
   package com.px.transaction;
   
   /**
    * 封装事务对象
    */
   public class Transaction {
       // 事务id
       private String transactionId;
       // 事务组id
       private String groupId;
       // 枚举事务状态，是Commit还是Rollback
       private TransactionType transactionType;
   
       public Transaction(String transactionId, String groupId) {
           this.transactionId = transactionId;
           this.groupId = groupId;
       }
   
       public String getTransactionId() {
           return transactionId;
       }
   
       public void setTransactionId(String transactionId) {
           this.transactionId = transactionId;
       }
   
       public String getGroupId() {
           return groupId;
       }
   
       public void setGroupId(String groupId) {
           this.groupId = groupId;
       }
   
       public TransactionType getTransactionType() {
           return transactionType;
       }
   
       public void setTransactionType(TransactionType transactionType) {
           this.transactionType = transactionType;
       }
   }
   ```

   枚举类：

   ```java
   // 事务枚举对象
   public enum TransactionType {
       COMMIT, ROLLBACK;
   }
   ```

   本地事务管理者：

   ```java
   package com.px.transaction;
   
   import com.alibaba.fastjson.JSONObject;
   import com.px.netty.NettyClient;
   
   import java.util.UUID;
   
   /**
    * 本地事务管理者
    * 将所有的事务操作都放在这个类里面
    */
   public class TransactionManager {
   
       // 注入NettyClient，因为这儿的NettyClient是静态不能直接注入，这儿使用set注入
       private static NettyClient nettyClient;
   		@Autowired
       public void setNettyClient(NettyClient nettyClient) {
           this.nettyClient = nettyClient;
       }
   
       // 创建事务组
       public static String createGroup() {
           // 使用uuid生成事务组id groupid
           String id = UUID.randomUUID().toString();
           // 要通过netty发送，所以使用JSONObject
           JSONObject jsonObject = new JSONObject();
           jsonObject.put("groupId", id);
           jsonObject.put("command", "create"); // 创建事务组的命令
   
           // 发送给Netty
           nettyClient.send(jsonObject);
           return id;
       }
   
       // 创建事务对象
   
       // 提交本地事务
   }
   ```

6. 这儿用到了Netty相关的类

   ```java
   package com.px.netty;
   
   import com.alibaba.fastjson.JSON;
   import com.alibaba.fastjson.JSONObject;
   import io.netty.channel.ChannelHandlerContext;
   import io.netty.channel.ChannelInboundHandlerAdapter;
   
   public class NettyClientHandler extends ChannelInboundHandlerAdapter {
   
       private ChannelHandlerContext context;
   
       @Override
       public void channelActive(ChannelHandlerContext ctx) throws Exception {
           context = ctx;
       }
   
       @Override
       public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {
           System.out.println("接受数据:" + msg.toString());
           JSONObject jsonObject = JSON.parseObject((String) msg);
   
           String groupId = jsonObject.getString("groupId");
           String command = jsonObject.getString("command");
           String transactionId = jsonObject.getString("transactionId");
   				// TODO
         	// 拿到事务对象
   
   
       }
   
       public synchronized Object call(JSONObject data) throws Exception {
           context.writeAndFlush(data.toJSONString()).channel().newPromise();
           return null;
       }
   }
   ```

   ```java
   package com.px.netty;
   
   import com.alibaba.fastjson.JSONObject;
   import io.netty.bootstrap.Bootstrap;
   import io.netty.channel.ChannelInitializer;
   import io.netty.channel.ChannelOption;
   import io.netty.channel.ChannelPipeline;
   import io.netty.channel.EventLoopGroup;
   import io.netty.channel.nio.NioEventLoopGroup;
   import io.netty.channel.socket.SocketChannel;
   import io.netty.channel.socket.nio.NioSocketChannel;
   import io.netty.handler.codec.string.StringDecoder;
   import io.netty.handler.codec.string.StringEncoder;
   import org.springframework.beans.factory.InitializingBean;
   
   /**
    * Netty 客户端
    */
   public class NettyClient implements InitializingBean {
   
       public NettyClientHandler client = null;
   
       @Override
       public void afterPropertiesSet() throws Exception {
           start("localhost", 8080);
       }
   
       public void start(String hostName, Integer port) {
           client = new NettyClientHandler();
           Bootstrap b = new Bootstrap();
           EventLoopGroup group = new NioEventLoopGroup();
           b.group(group)
                   .channel(NioSocketChannel.class)
                   .option(ChannelOption.TCP_NODELAY, true)
                   .handler(new ChannelInitializer<SocketChannel>() {
                       protected void initChannel(SocketChannel socketChannel) throws Exception {
                           ChannelPipeline pipeline = socketChannel.pipeline();
                           pipeline.addLast("decoder", new StringDecoder());
                           pipeline.addLast("encoder", new StringEncoder());
                           pipeline.addLast("handler", client);
                       }
                   });
   
           try {
               b.connect(hostName, port).sync();
           } catch (InterruptedException e) {
               e.printStackTrace();
           }
       }
   
       // 发送
       public void send(JSONObject jsonObject) {
           try {
               client.call(jsonObject);
           } catch (Exception e) {
               e.printStackTrace();
           }
       }
   }
   ```

   `NettyClientHandler`这个类里面还有些后续的部分，后面再补上

7. 所以我们可以继续在我们的切面创建事务组

   ```java
   /**
    * 分布式事务切面
    */
   @Aspect
   @Component
   public class TransactionAspect {
   
       @Around("@annotation(com.px.annotation.MyTransaction)")
       public void invoke(ProceedingJoinPoint proceedingJoinPoint) {
           // 首先拿到方法对象
           MethodSignature signature = (MethodSignature) proceedingJoinPoint.getSignature();
           // 拿到我们的注解对象
           MyTransaction annotation = signature.getMethod().getAnnotation(MyTransaction.class);
           // 事务组id
           String group = "";
           if (annotation.isStart()) {
               // 创建事务组
               group = TransactionManager.createGroup();
           } else {
               // 拿到当前事务组的id, 通过ThreadLocal拿到
               // 这样写可能会拿到null
               group = TransactionManager.getCurrent();
           }
           // 执行本地逻辑
           // 创建事务对象
   
   
           // 如果有@MyTransaction标注，但是没有start也没有end，
           // 比如在服务中间的一个服务，如什么积分服务之类的，说明
           // 她肯定存在分布式事务里面，同时存在这个group里面，那么我们这儿
           // 怎么拿到group的id？所以在生成group那边的类里面维护一个保存groupId的ThredLocal
   
       }
   }
   ```

   如上面的注释所说，如果有一个中间服务，也标注了我们自己定义的`@MyTransaction`注解的话，那么该怎么拿到gourpId呢？所以在生成group那边的类里面维护一个保存groupId的ThredLocal，**但是这个方式也可能拿到空的，后续再提供groupId转移的操作**

   `TransactionManager`

   ```java
   package com.px.transaction;
   
   import com.alibaba.fastjson.JSONObject;
   import com.px.netty.NettyClient;
   
   import java.util.UUID;
   
   /**
    * 本地事务管理者
    * 将所有的事务操作都放在这个类里面
    */
   public class TransactionManager {
   
       // 维护一个ThreadLocal，存储groupID， 主要是标注了@MyTransaction注解的一些个中间服务
       // 方便它们拿到groupId
       private static ThreadLocal<String> CURRENT = new ThreadLocal<>();
   
       // 注入NettyClient，因为这儿的NettyClient是静态不能直接注入，这儿使用set注入
       private static NettyClient nettyClient;
   		@Autowired
       public void setNettyClient(NettyClient nettyClient) {
           this.nettyClient = nettyClient;
       }
   
       // 创建事务组
       public static String createGroup() {
           // 使用uuid生成事务组id groupid
           String id = UUID.randomUUID().toString();
           // 要通过netty发送，所以使用JSONObject
           JSONObject jsonObject = new JSONObject();
           jsonObject.put("groupId", id);
           jsonObject.put("command", "create"); // 创建事务组的命令
   
           // 发送给Netty
           CURRENT.set(id);
           nettyClient.send(jsonObject);
           return id;
       }
   
       // 创建事务对象
       public static Transaction createTransaction(String groupId) {
           // 事务id, 通过uuid来实现
           String transactionId = UUID.randomUUID().toString();
           Transaction transaction = new Transaction(transactionId, groupId);
           return transaction;
       }
   
   
       // 提交本地事务
   
       public static String getCurrent() {
           return CURRENT.get();
       }
   }
   ```

   **因为在接下来的切面里面会去创建本地事务对象，所以在本地事务管理里面已经添加了这个方法`createTransaction`来创建事务对象**

8. 继续在切面完成后面的逻辑

   ```java
   // 创建事务对象
   Transaction transaction = TransactionManager.createTransaction(group);
   // 执行本地逻辑
   try {
     // Spring会帮我们执行mysql的逻辑，让spring告诉我们失败或者成功
     // 但是这儿会有一个优先级的问题，因为我们要让spring的@Transactional先执行
     // 然后再调用到我们的Connection在commit前等待，所以我们的注解需要后执行，所以添加一个Order注解
     Object proceed = proceedingJoinPoint.proceed();
     // 提交本地事务状态 COMMIT操作
   } catch (Throwable throwable) {
     // ROLLBACK操作
     throwable.printStackTrace();
   }
   ```

   我们需要在本地事务管理地方提交本地事务的**状态**，所以在`TransactionManager`中添加方法：

   ```java
   // 提交本地事务到事务管理者服务端
   public void commitTransaction(Transaction transaction, boolean isEnd, TransactionType transactionType) {
       JSONObject jsonObject = new JSONObject();
       jsonObject.put("groupId", transaction.getGroupId());
       jsonObject.put("transactionId", transaction.getTransactionId());
       jsonObject.put("transactionType", transaction.getTransactionType());
       jsonObject.put("command", "add");
       jsonObject.put("isEnd", isEnd);
       nettyClient.send(jsonObject);
       System.out.println("执行了添加事务");
   
   }
   ```

   回到我们的切面继续向下执行

   ```java
   try {
       // Spring会帮我们执行mysql的逻辑，让spring告诉我们失败或者成功
       // 但是这儿会有一个优先级的问题，因为我们要让spring的@Transactional先执行
       // 然后再调用到我们的Connection在commit前等待，所以我们的注解需要后执行，所以添加一个Order注解
       Object proceed = proceedingJoinPoint.proceed();
       // 提交本地事务状态 COMMIT操作
       TransactionManager.commitTransaction(transaction, annotation.isEnd(), TransactionType.COMMIT);
   } catch (Throwable throwable) {
       // ROLLBACK操作
       TransactionManager.commitTransaction(transaction, annotation.isEnd(), TransactionType.ROLLBACK);
       throwable.printStackTrace();
   }
   ```

9. 回到我们开始拿到connection的地方，我们之前说过，需要在spring commit之前等待，所以我们这儿设计一个任务类，用于等待和唤醒事务。

   ```java
   package com.px.task;
   
   import java.util.concurrent.locks.Condition;
   import java.util.concurrent.locks.Lock;
   import java.util.concurrent.locks.ReentrantLock;
   
   /**
    * 任务类
    * 在提交本地事务之前进行等待
    */
   public class Task {
   
       private Lock lock = new ReentrantLock();
   
       private Condition condition = lock.newCondition();
   
       // 等待
       public void waitTask() {
           try {
               lock.lock();
               condition.await();
           } catch (InterruptedException e) {
               e.printStackTrace();
           } finally {
               lock.unlock();
           }
       }
   
       // 唤醒
       public void singalTask() {
           lock.lock();
           condition.signal();
           lock.unlock();
       }
   }
   ```

   Task类的初始化放在了本地事务对象transaction里面：

   ```java
   /**
    * 封装事务对象
    */
   public class Transaction {
       // 事务id
       private String transactionId;
       // 事务组id
       private String groupId;
       // 枚举事务状态，是Commit还是Rollback
       private TransactionType transactionType;
       // 任务
       private Task task;
   
       public Transaction(String transactionId, String groupId) {
           this.transactionId = transactionId;
           this.groupId = groupId;
           // 构造的时候附带一个任务
           task = new Task();
       }
   
       public String getTransactionId() {
           return transactionId;
       }
   
       public void setTransactionId(String transactionId) {
           this.transactionId = transactionId;
       }
   
       public String getGroupId() {
           return groupId;
       }
   
       public void setGroupId(String groupId) {
           this.groupId = groupId;
       }
   
       public TransactionType getTransactionType() {
           return transactionType;
       }
   
       public void setTransactionType(TransactionType transactionType) {
           this.transactionType = transactionType;
       }
   
       public Task getTask() {
           return task;
       }
   
       public void setTask(Task task) {
           this.task = task;
       }
   }
   ```

   这儿涉及到lock和condition的一些知识，后面再去补充下，然后我们在connection 提交和回滚的地方加入我们的逻辑，在提交之前我们需要判断事务的状态，所以我们需要把事务传进来。

   ```java
   /**
    * 自定义连接，将自己封装的connection给spring
    * 因为spring底层也是通过dataSource来拿到connection对象
    */
   public class MyConnection implements Connection {
   
       // Spring实现的connection
       private Connection connection;
       // 把事务对象给过来，方便对其进行唤醒和等待操作
       private Transaction transaction;
   
       public MyConnection(Connection connection, Transaction transaction) {
           this.connection = connection;
           this.transaction = transaction;
       }
   
       @Override
       public void commit() throws SQLException {
           // 我们自己的逻辑
           // 在提交之前需要等待, 需要拿到唤醒的事务对像，等待事务管理者通知
           this.transaction.getTask().waitTask();
           if (TransactionType.COMMIT.equals(transaction.getTransactionType())) {
               // 提交
               this.connection.commit();
           } else {
               this.connection.rollback();
           }
       }
   
       @Override
       public void rollback() throws SQLException {
           this.transaction.getTask().waitTask();
           this.connection.rollback();
       }
   
       @Override
       public void close() throws SQLException {
           this.connection.close();
       }
   }       
   ```

   但是这儿可能会出现**死锁**的问题，因为在切面的时候我们是先让spring执行提交操作，然后spring又在这儿等待事务管理者通知，所以问题来了：**如果Spring不执行完commit操作，我们就没有办法提交状态到事务管理者，而spring又在等待事务管理者的通知**，所以会锁在这儿。

   所以我们通过开启线程的方式去处理，后面可以考虑维护一个线程池来优化，**如果开启线程，那么spring会继续向下执行，然后会执行close方法，所以close里面不执行任何操作，将close的部分放在线程执行完后面的部分**

   ```java
   /**
    * 自定义连接，将自己封装的connection给spring
    * 因为spring底层也是通过dataSource来拿到connection对象
    */
   public class MyConnection implements Connection {
   
       // Spring实现的connection
       private Connection connection;
       // 把事务对象给过来，方便对其进行唤醒和等待操作
       // 这个事务对象就是本地事务的对象
       private Transaction transaction;
   
       public MyConnection(Connection connection, Transaction transaction) {
           this.connection = connection;
           this.transaction = transaction;
       }
   
       @Override
       public void commit() throws SQLException {
           // 我们自己的逻辑
           // 在提交之前需要等待, 需要拿到唤醒的事务对像，等待事务管理者通知
   //        this.transaction.getTask().waitTask();
   //        if (TransactionType.COMMIT.equals(transaction.getTransactionType())) {
   //            // 提交
   //            this.connection.commit();
   //        } else {
   //            this.connection.rollback();
   //        }
           // 开启线程，防止spring提交一直等待的问题，也就是死锁
           new Thread(() -> {
               this.transaction.getTask().waitTask();
               try {
                   if (TransactionType.COMMIT.equals(transaction.getTransactionType())) {
                       this.connection.commit();
                   } else {
                       this.connection.rollback();
                   }
                   this.connection.close();
               } catch (SQLException e) {
                   e.printStackTrace();
               }
   
           }).start();
       }
   
       @Override
       public void rollback() throws SQLException {
           new Thread(() -> {
               this.transaction.getTask().waitTask();
               try {
                   this.connection.rollback();
                   this.connection.close();
               } catch (SQLException e) {
                   e.printStackTrace();
               }
           }).start();
       }
   
       /**
        * 因为我们这儿开启了一个线程去等待，spring会马上执行close方法，所以我们这儿不能让
        * 它close，让它执行完我们的逻辑在close
        * @throws SQLException
        */
       @Override
       public void close() throws SQLException {
           // this.connection.close();
       }
   }    
   ```

10. 现在我们回到netty的客户端，继续之前我们没有完成的逻辑，我们需要对指定事务放行

   ```java
   /**
    * netty客户端
    */
   public class NettyClientHandler extends ChannelInboundHandlerAdapter {
   
       private ChannelHandlerContext context;
   
       @Override
       public void channelActive(ChannelHandlerContext ctx) throws Exception {
           context = ctx;
       }
   
       @Override
       public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {
           System.out.println("接受数据:" + msg.toString());
           JSONObject jsonObject = JSON.parseObject((String) msg);
   
           String groupId = jsonObject.getString("groupId");
           String command = jsonObject.getString("command");
           String transactionId = jsonObject.getString("transactionId");
   
           System.out.println("command: " + command);
           // 对事务进行操作
           // 对指定事务放行，怎么拿到指定事务呢？所以我们需要根据事务id去拿到，那么我们需要维护一个map
           // 在本地事务管理者里面，维护事务组的map
           // 拿到通知的事务对象
           Transaction transaction = TransactionManager.getTransactionById(groupId, transactionId);
           // 有可能订单微服务和库存微服务会在一个事务组里面，肯定会通知两次，
           // 订单本地可能接受库存微服务的事务，所以可能为空
           if (transaction != null) {
               if ("rollback".equals(command)) {
                   // 回滚
                   transaction.setTransactionType(TransactionType.ROLLBACK);
               } else {
                   // 提交
                   transaction.setTransactionType(TransactionType.COMMIT);
               }
           }
       }
   
       public synchronized Object call(JSONObject data) throws Exception {
           context.writeAndFlush(data.toJSONString()).channel().newPromise();
           return null;
       }
   }
   ```

   netty客户端要对指定事务放行，首先需要拿到指定的事务，所以我们再本地事务管理者类里面加入维护一个map，来存事务，在创建事务组的时候以及创建本地事务的时候put进去，方便我们再netty客户端的地方拿到。

   ```java
   public class TransactionManager {
   
       // 维护一个ThreadLocal，存储groupID， 主要是标注了@MyTransaction注解的一些个中间服务
       // 方便它们拿到groupId
       private static ThreadLocal<String> CURRENT = new ThreadLocal<>();
   
       // 维护一个map，存放事务， 方便netty客户端获取
       private static Map<String, Map<String, Transaction>> GROUP_MAP = new HashMap<>();
   
       // 注入NettyClient，因为这儿的NettyClient是静态不能直接注入，这儿使用set注入
       private static NettyClient nettyClient;
   
       @Autowired
       public void setNettyClient(NettyClient nettyClient) {
           this.nettyClient = nettyClient;
       }
   
       // 创建事务组
       public static String createGroup() {
           // 使用uuid生成事务组id groupid
           String id = UUID.randomUUID().toString();
           // 要通过netty发送，所以使用JSONObject
           JSONObject jsonObject = new JSONObject();
           jsonObject.put("groupId", id);
           jsonObject.put("command", "create"); // 创建事务组的命令
           // threadlocal放入事务组id
           CURRENT.set(id);
           // 将事务放进GROUP_Map
           GROUP_MAP.put(id, new HashMap<>());
           // 发送给Netty
           nettyClient.send(jsonObject);
           return id;
       }
   
       // 创建本地事务对象
       public static Transaction createTransaction(String groupId) {
           // 事务id, 通过uuid来实现
           String transactionId = UUID.randomUUID().toString();
           Transaction transaction = new Transaction(transactionId, groupId);
           // 将事务放进GROUP_MAP里面
           if (GROUP_MAP.get(groupId) == null) {
               // 会出现空的现象，假设订单服务这儿是start状态，而库存就不是，所以也会创建事务，这儿就会为空
               GROUP_MAP.put(groupId, new HashMap<>());
           }
           GROUP_MAP.get(groupId).put(transactionId, transaction);
           return transaction;
       }
   
       // 提交本地事务到事务管理者服务端
       public static void commitTransaction(Transaction transaction, boolean isEnd, TransactionType transactionType) {
           JSONObject jsonObject = new JSONObject();
           jsonObject.put("groupId", transaction.getGroupId());
           jsonObject.put("transactionId", transaction.getTransactionId());
           jsonObject.put("transactionType", transaction.getTransactionType());
           jsonObject.put("command", "add");
           jsonObject.put("isEnd", isEnd);
           nettyClient.send(jsonObject);
           System.out.println("执行了添加事务");
   
       }
   
       /**
        * 通过事务组id和事务id拿到事务对象
        * @param groupId
        * @param transactionId
        * @return
        */
       public static Transaction getTransactionById(String groupId, String transactionId) {
           return GROUP_MAP.get(groupId).get(transactionId);
       }
   }
   ```

11. 之前在connection的地方需要传入本地事务对象来判断事务是否提交或者回滚，那么这个本地事务对象从哪儿来呢？

    在注解`@MyTransaction`的切面逻辑里面，我们是先创建了本地事务对象，然后再让spring执行，最后再提交本地事务状态到事务管理者服务端。

    ```java
    // 创建事务对象 这儿创建的是本地事务对象
    Transaction transaction = TransactionManager.createTransaction(group);
    // 执行本地逻辑
    try {
        // Spring会帮我们执行mysql的逻辑，让spring告诉我们失败或者成功
        // 但是这儿会有一个优先级的问题，因为我们要让spring的@Transactional先执行
        // 然后再调用到我们的Connection在commit前等待，所以我们的注解需要后执行，所以添加一个Order注解
        Object proceed = proceedingJoinPoint.proceed();
        // 提交本地事务状态 COMMIT操作
        TransactionManager.commitTransaction(transaction, annotation.isEnd(), TransactionType.COMMIT);
    } catch (Throwable throwable) {
        // ROLLBACK操作
        TransactionManager.commitTransaction(transaction, annotation.isEnd(), TransactionType.ROLLBACK);
        throwable.printStackTrace();
    }
    ```

    所以本地事务在切面里面已经创建了，那么怎么将其传给我们定义的connction呢，及如下构造方法的参数：

    ```java
    // 配置连接切面，截取spring获取的DataSource连接，然后返回我们自定义的连接对象
    @Aspect
    @Component
    public class ConnectionAspect {
    
        // 代理Datasource的connection
        @Around("execution(* javax.sql.DataSource.getConnection(..))")
        public Connection around(ProceedingJoinPoint proceedingJoinPoint) {
            try {
                // 拿到spring的connection对象
                Connection connection = (Connection) proceedingJoinPoint.proceed();
                // 最终spring的connection对象是我们自己的connection对象
                return new MyConnection(connection, XXXXXXXXXXXX);
            } catch (Throwable throwable) {
                throwable.printStackTrace();
            }
            return null;
        }
    ```

    我们可以通过本地线程对象即ThreadLocal的方式来进行传输，即另一个ThreadLocal，之前的ThreadLocal是存放groupId的，我们在本地事务管理者里面新加一个：

    ```java
    /**
     * 本地事务管理者
     * 将所有的事务操作都放在这个类里面
     */
    public class TransactionManager {
    
        // 维护一个ThreadLocal，存储groupID， 主要是标注了@MyTransaction注解的一些个中间服务
        // 方便它们拿到groupId
        private static ThreadLocal<String> CURRENT = new ThreadLocal<>();
    
        // 维护一个map，存放事务， 方便netty客户端获取
        private static Map<String, Map<String, Transaction>> GROUP_MAP = new HashMap<>();
    
        // 维护一个threadLocal，存放本地事务对象，方便切面拿到connection之前传入
        private static ThreadLocal<Transaction> CURREN_TRANSACTION = new ThreadLocal<>();
    
        // 注入NettyClient，因为这儿的NettyClient是静态不能直接注入，这儿使用set注入
        private static NettyClient nettyClient;
      
    		@Autowired
        public void setNettyClient(NettyClient nettyClient) {
            this.nettyClient = nettyClient;
        }
        // 创建事务对象
        public static Transaction createTransaction(String groupId) {
            // 事务id, 通过uuid来实现
            String transactionId = UUID.randomUUID().toString();
            Transaction transaction = new Transaction(transactionId, groupId);
            // 将事务放进GROUP_MAP里面
            if (GROUP_MAP.get(groupId) == null) {
                // 会出现空的现象，假设订单服务这儿是start状态，而库存就不是，所以也会创建事务，这儿就会为空
                GROUP_MAP.put(groupId, new HashMap<>());
            }
            GROUP_MAP.get(groupId).put(transactionId, transaction);
            // 在创建本地事务对象之后将事务对象放入本地线程之中
            CURREN_TRANSACTION.set(transaction);
            return transaction;
        }
        /**
         * 拿到当前线程中的事务对象，即本地事务
         * @return
         */
        public static Transaction getCurrentTransaction() {
            return CURREN_TRANSACTION.get();
        }
    
    }
    ```

    所以在connection的切面里面可以有如下：

    ```java
    // 代理Datasource的connection
    @Around("execution(* javax.sql.DataSource.getConnection(..))")
    public Connection around(ProceedingJoinPoint proceedingJoinPoint) {
        try {
            // 拿到spring的connection对象
            Connection connection = (Connection) proceedingJoinPoint.proceed();
            // 最终spring的connection对象是我们自己的connection对象
            return new MyConnection(connection, TransactionManager.getCurrentTransaction());
        } catch (Throwable throwable) {
            throwable.printStackTrace();
        }
        return null;
    }
    ```

12. 到此已经完成了大部分的逻辑，最后还有一个问题就是订单微服务需要把事务组的id即groupid发送给库存微服务，为此我们封装一个类，将groupId放在请求头里面，然后库存微服务通过一个拦截器获取放入本地线程对象里面：

    ```java
    package com.px.task;
    
    import com.px.transaction.TransactionManager;
    import org.springframework.http.HttpHeaders;
    import org.springframework.http.HttpEntity;
    import org.springframework.stereotype.Component;
    import org.springframework.util.MultiValueMap;
    import org.springframework.web.client.RestTemplate;
    
    /**
     * 封装一个工具，将事务组id放在请求头里面发送给其他服务
     */
    @Component
    public class HttpUtil {
    
        private static RestTemplate restTemplate = new RestTemplate();
    
        public  static Object post(String url){
            HttpHeaders header = new HttpHeaders();
          	// 从本地线程中获取事务组id，封装到
            header.set("groupId", TransactionManager.getCurrent());
            HttpEntity<MultiValueMap<String, String>> httpEntity = new HttpEntity<>(null, header);
            return  restTemplate.postForObject(url,httpEntity,Object.class);
    
        }
    }
    ```

    拦截器：

    ```java
    package com.px.interceptor;
    
    import org.springframework.context.annotation.Configuration;
    import org.springframework.web.servlet.config.annotation.InterceptorRegistry;
    import org.springframework.web.servlet.config.annotation.WebMvcConfigurerAdapter;
    
    @Configuration
    public class WebAppConfig extends WebMvcConfigurerAdapter {
    
        @Override
        public void addInterceptors(InterceptorRegistry registry) {
            registry.addInterceptor(new RequestInterceptor());
        }
    }
    ```

    ```java
    /**
     * 创建拦截器，从请求头里面拿到groupId，然后放进本地线程里面
     */
    @Component
    public class RequestInterceptor implements HandlerInterceptor {
    
        @Override
        public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {
            String groupId = request.getHeader("groupId");
            // TransactionMangage.setCurrent(groupId);
            TransactionManager.setCurrent(groupId);
            return true;
        }
    
        @Override
        public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception {
    
        }
    
        @Override
        public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception {
    
        }
    }
    ```

    本地事务管理者里面缺了一个set当前groupId的方法，这儿一并加上：

    ```java
    // 拿到事务组的id
    public static String getCurrent() {
        return CURRENT.get();
    }
    
    // set事务组id到本地线程中
    public static void setCurrent(String groupId) {
        CURRENT.set(groupId);
    }
    ```

13. 最后来看下一个事务管理者服务端的代码，这儿用的是netty，netty我暂时不太懂，抄的代码，顺便提一句，事务管理者服务端是一个单独的项目`px-transaction-manager`

    ```java
    import io.netty.bootstrap.ServerBootstrap;
    import io.netty.channel.ChannelInitializer;
    import io.netty.channel.ChannelPipeline;
    import io.netty.channel.nio.NioEventLoopGroup;
    import io.netty.channel.socket.SocketChannel;
    import io.netty.channel.socket.nio.NioServerSocketChannel;
    import io.netty.handler.codec.string.StringDecoder;
    import io.netty.handler.codec.string.StringEncoder;
    public class NettyServer {
        public void start(String hostName, int port) {
            try {
                final ServerBootstrap bootstrap = new ServerBootstrap();
                NioEventLoopGroup eventLoopGroup = new NioEventLoopGroup();
                bootstrap.group(eventLoopGroup)
                        .channel(NioServerSocketChannel.class)
                        .childHandler(new ChannelInitializer<SocketChannel>() {
    
                            protected void initChannel(SocketChannel socketChannel) throws Exception {
                                ChannelPipeline pipeline = socketChannel.pipeline();
                                pipeline.addLast("decoder", new StringDecoder());
                                pipeline.addLast("encoder", new StringEncoder());
                                pipeline.addLast("handler", new NettyServerHandler());
                            }
                        });
                bootstrap.bind(hostName, port).sync();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    
        public void close() {
    
        }
    }
    ```

    ```java
    package com.px.server;
    
    import com.alibaba.fastjson.JSON;
    import com.alibaba.fastjson.JSONObject;
    import io.netty.channel.Channel;
    import io.netty.channel.ChannelHandlerContext;
    import io.netty.channel.ChannelInboundHandlerAdapter;
    import io.netty.channel.group.ChannelGroup;
    import io.netty.channel.group.DefaultChannelGroup;
    import io.netty.util.concurrent.GlobalEventExecutor;
    
    import java.util.ArrayList;
    import java.util.HashMap;
    import java.util.List;
    import java.util.Map;
    
    /**
     * 作为事务管理者，它需要：
     * 1. 创建并保存事务组
     * 2. 保存各个子事务在对应的事务组内
     * 3. 统计并判断事务组内的各个子事务状态，以算出当前事务组的状态（提交or回滚）
     * 4. 通知各个子事务提交或回滚
     */
    
    public class NettyServerHandler extends ChannelInboundHandlerAdapter {
    
        private static ChannelGroup channelGroup = new DefaultChannelGroup(GlobalEventExecutor.INSTANCE);
    
        // 事务组中的事务状态列表
        private static Map<String, List<String>> transactionTypeMap = new HashMap<String, List<String>>();
        // 事务组是否已经接收到结束的标记
        private static Map<String, Boolean> isEndMap = new HashMap<String, Boolean>();
    
    //    // 事务组中应该有的事务个数
    //    private static Map<String, Integer> transactionCountMap = new HashMap<String, Integer>();
    
        @Override
        public void handlerAdded(ChannelHandlerContext ctx) throws Exception {
            Channel channel = ctx.channel();
            channelGroup.add(ctx.channel());
        }
    
        /**
         * 创建事务组，并且添加保存事务
         * 并且需要判断，如果所有事务都已经执行了（有结果了，要么回滚，要么提交），且其中有一个事务需要回滚，那么通知所有客户端进行回滚
         * 否则，则通知所有客户端进行提交
         * @param ctx
         * @param msg
         * @throws Exception
         */
    
        @Override
        public synchronized void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {
            System.out.println("接受数据:" + msg.toString());
    
            JSONObject jsonObject = JSON.parseObject((String) msg);
    
            String command = jsonObject.getString("command"); // create-创建事务组，add-添加事务
            String groupId = jsonObject.getString("groupId");   // 事务组id
            String transactionType = jsonObject.getString("transactionType"); // 子事务类型，commit-待提交，rollback-待回滚
            Integer transactionCount = jsonObject.getInteger("transactionCount");   // 事务数量
            Boolean isEnd = jsonObject.getBoolean("isEnd"); // 是否是结束事务
            String transactionId = jsonObject.getString("transactionId");//事物ID
    
    
            if ("create".equals(command)) {
                // 创建事务组
                transactionTypeMap.put(groupId, new ArrayList<String>());
            } else if ("add".equals(command)) {
                // 加入事务组
                transactionTypeMap.get(groupId).add(transactionType);
    
                if (isEnd) {
                    isEndMap.put(groupId, true);
    //                transactionCountMap.put(groupId, transactionCount);
                }
    
                JSONObject result = new JSONObject();
                result.put("groupId", groupId);
                result.put("transactionId",transactionId);
                // 如果已经接收到结束事务的标记,则看是否需要回滚
                if (isEndMap.get(groupId)) {
                    //commit
                    //commit
                    //commit
                    if (transactionTypeMap.get(groupId).contains("ROLLBACK")){
                        result.put("command", "rollback");
                        sendResult(result);
                    } else {
                        result.put("command", "commit");
                        sendResult(result);
                    }
                }
    
            }
        }
    
        private void sendResult(JSONObject result) {
            for (Channel channel : channelGroup) {
                System.out.println("发送数据:" + result.toJSONString());
                channel.writeAndFlush(result.toJSONString());
            }
        }
    }
    ```

    启动类方法

    ```java
    public class TxManagerMain {
    
        public static void main(String[] args) {
            NettyServer nettyServer = new NettyServer();
            nettyServer.start("localhost", 8080);
            System.out.println("netty 启动成功");
        }
    }
    ```

14. 测试

    在两个服务里面引入依赖：

    ```xml
    <dependency>
      <groupId>com.px</groupId>
      <artifactId>px-transaction</artifactId>
      <version>0.0.1-SNAPSHOT</version>
    </dependency>
    ```

    在服务一service方法上加上注解以及使用http工具访问

    ```java
    @Service
    public class DemoService {
    
        @Autowired
        private Demodao demoDao;
    
        @Autowired
        private RestTemplate restTemplate;
    
        @Transactional
        @MyTransaction(isStart = true)
        public R test() {
            demoDao.insert("server1");
            Object post = HttpUtil.post("http://localhost:8082/server2/test");
            // Object o = restTemplate.postForObject("http://localhost:8082/server2/test", null, Object.class);
            int i = 1/0;
            return R.success("", post);
        }
    }
    ```

    在服务二上service方法加上注解，标注isEnd = true，这代表了事务的结束。

    ```java
    @Service
    public class DemoService {
    
        @Autowired
        private DemoDao demoDao;
    
        @MyTransaction(isEnd = true)
        @Transactional
        public void test() {
            demoDao.insert("server2");
        }
    }
    ```

15. 访问链接测试

16. 

    

## MQ方式

## TCC方式

