## 定义

定义一个创建对象的接口，但让实现这个接口的类来决定实例化哪个类，工厂方法让类的实例化推迟到子类中进行。

## 类型

创建型

## 适用场景

+ 创建对象需要大量重复的代码。
+ 客户端（应用层）不依赖于产品类实例如何被创建、实现等细节。
+ 一个类通过其子类来指定创建哪个对象

## 代码

使用Video这**同一个产品等级**来模拟工厂方法模式。比如美的冰箱和海尔冰箱是同一个产品等级，而美的冰箱和空调是属于美的这个产品族，而海尔冰箱和空调是属于海尔这个产品族的。

```java
public interface Vedio {
    public void produce();
}
```

```java
public class JavaVedio implements Vedio {

    public void produce() {
        System.out.println("Java");
    }
}
```

```java
public class PythodVideo implements Vedio {

    public void produce() {
        System.out.println("python");
    }
}
```

```java
// 实际业务场景，这个类对应某些行为是已知，除了这个未知的还有一些个已知的方法，所以用抽象类
public abstract class VedioFactory {

    public abstract Vedio getVedio();
}
```

```java
public class JavaVideoFactory extends VedioFactory {

    public Vedio getVedio() {
        return new JavaVedio();
    }
}
```

```java
public class PythonVideoFactory extends VedioFactory {

    public Vedio getVedio() {
        return new PythodVideo();
    }
}
```

测试

```java
public class Test {

    public static void main(String[] args) {
        VedioFactory vedioFactory = new JavaVideoFactory();
        Vedio vedio = vedioFactory.getVedio();
        vedio.produce();
    }
}
```

## 源码体现

```java
Iterator<E> iterator();
```

Collection接口里面的`iterator()`对应子类不同有不同的实现，比如ArrayList

```java
public Iterator<E> iterator() {
    return new Itr();
}

/**
 * An optimized version of AbstractList.Itr
 */
private class Itr implements Iterator<E> {
    int cursor;       // index of next element to return
    int lastRet = -1; // index of last element returned; -1 if no such
    int expectedModCount = modCount;

    public boolean hasNext() {
        return cursor != size;
    }

    @SuppressWarnings("unchecked")
    public E next() {
        checkForComodification();
        int i = cursor;
        if (i >= size)
            throw new NoSuchElementException();
        Object[] elementData = ArrayList.this.elementData;
        if (i >= elementData.length)
            throw new ConcurrentModificationException();
        cursor = i + 1;
        return (E) elementData[lastRet = i];
    }

    public void remove() {
        if (lastRet < 0)
            throw new IllegalStateException();
        checkForComodification();

        try {
            ArrayList.this.remove(lastRet);
            cursor = lastRet;
            lastRet = -1;
            expectedModCount = modCount;
        } catch (IndexOutOfBoundsException ex) {
            throw new ConcurrentModificationException();
        }
    }

    @Override
    @SuppressWarnings("unchecked")
    public void forEachRemaining(Consumer<? super E> consumer) {
        Objects.requireNonNull(consumer);
        final int size = ArrayList.this.size;
        int i = cursor;
        if (i >= size) {
            return;
        }
        final Object[] elementData = ArrayList.this.elementData;
        if (i >= elementData.length) {
            throw new ConcurrentModificationException();
        }
        while (i != size && modCount == expectedModCount) {
            consumer.accept((E) elementData[i++]);
        }
        // update once at end of iteration to reduce heap write traffic
        cursor = i;
        lastRet = i - 1;
        checkForComodification();
    }

    final void checkForComodification() {
        if (modCount != expectedModCount)
            throw new ConcurrentModificationException();
    }
}
```