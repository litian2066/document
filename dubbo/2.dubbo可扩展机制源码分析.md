# Dubbo的可扩展机制源码分析

![page1image33620176.png](./img/7.png) 

注意：

在dubbo消费者端调用服务提供者的服务的时候拿到实现类是**代理类**，需要构造invoker对象再拿到方法。

## Java SPI

JDK标准的SPI会一次性实例化扩展点所有实现，如果有扩展实现初始化很耗时，但如果没用上也加载，会很浪费资源。

1. 比如一个框架有一个jar包，有一个interface的接口，如果现在想往这个框架里面添加一个实现类

2. 自己写的代码里面去实现这个接口，把实现类定义在`MATA-INF.service`对应的接口文件里面(SPI)，最后打成jar包

3. 现在就可以把框架的jar包和我们自己写的jar包放在我们自己的项目里面，如果框架是通过SPI的方式去实现的，就可以加载我们自己的实现了类 


再来打个比方：

1. 比如说现在有一个框架，它有一个interface，自己有一个默认的实现类
2. 这个interface越来越火，很多第三方公司都在用，开源了，很多的人或者组织觉得好，就想去扩展它，继而有自己的一个实现类
3. 现在我就在想，我再用到你这个框架的时候怎么能用到我自己写的实现类？
4. 还是通过SPI的方式把实现类写在一个文件里面放在classpath下面
5. 如果我们项目想用这些第三方的实现类，我们可以把他们打成一个jar包放在我们的项目里面
6. 通过`serviceLoad`的方式调用即可

弊端：

1. 全部加载，耗费资源

具体代码：

0. 创建测试接口`CarInterface`以及几个实现类：

   ````java
   @SPI
   public interface CarInterface {
       // 获得颜色
       public void getColor();
   
   }
   ````

   ````java
   public class BlackCar implements CarInterface {
       @Override
       public void getColor() {
           System.out.println("black");
       }
   }
   ````

   ````java
   public class RedCar implements CarInterface {
       @Override
       public void getColor() {
           System.out.println("red");
       }
   }
   ````

1. 在`resources`目录下创建`MATE-INF/services`目录

2. 在其下新建一个文件，将自己定义的接口的全路径作为文件名字，如图：

   ![](./img/8.jpg)

3. 在文件里面一行一行写出实现类的全路径

   ````
   com.test.BlackCar
   com.test.RedCar
   ````

4. 通过API调用

   ````java
   public static void main(String[] args) {
     ServiceLoader<CarInterface> serviceLoader = ServiceLoader.load(CarInterface.class);
     Iterator<CarInterface> iterator = serviceLoader.iterator();
     while (iterator.hasNext()) {
       CarInterface carInterface = iterator.next();
       carInterface.getColor();
     }
   }
   ````
   

结果：

````java
   black
   red
````

**需要对被扩展的接口上加上`@SPI`的注解**

## Dubbo SPI􏰣􏰤􏰤􏰥 􏳀􏲿􏲳􏰢􏰣􏰤􏰤􏰥 􏳀􏲿􏲳

上面说道JDK SPI耗费资源，而Dubbo对JDK SPI进行了优化，不再是对资源全部加载，而是通过key/value的形式来进行加载。

1. 将对应文件里面的实现类修改为key/value的形式

   ````
   black = com.test.BlackCar
   red = com.test.RedCar
   ````

2. 然后API通过get获取，如下：

3. ````java
   public static void main(String[] args) {
     ExtensionLoader<CarInterface> extensionLoader =
       													ExtensionLoader.getExtensionLoader(CarInterface.class);
     CarInterface carInterface = extensionLoader.getExtension("black");
     carInterface.getColor();
   }
   ````

   ````
   black
   ````

4. **Dubbo自动包装**

   1. 新建一个wrapper类

      ````java
      public class CarWrapper implements CarInterface{
      
          private CarInterface carInterface;
      
          public CarWrapper(CarInterface carInterface) {
              this.carInterface = carInterface;
          }
      
          @Override
          public void getColor() {
              System.out.println("before");
              carInterface.getColor();
              System.out.println("after");
          }
      }
      
      ````

   2. 将wrapper类加入到SPI的配置文件当中

      ```
      black = com.test.BlackCar
      red = com.test.RedCar
      com.test.CarWrapper
      ```

   3. 执行上面的测试代码，对方法进行了增强

      ````java
      before
      black
      after
      ````

   4. 也可以进行层层的增强，比如再新增一个warpper类

      ````java
      public class CarWrapper2 implements CarInterface {
      
          private CarInterface carInterface;
      
          public CarWrapper2(CarInterface carInterface) {
              this.carInterface = carInterface;
          }
      
          @Override
          public void getColor() {
              System.out.println("before2");
              carInterface.getColor();
              System.out.println("after2");
          }
      }
      ````

   5. 再将这个类加入到SPI的配置文件当中去，就放在第一个wrapper类的下面

      ````
      black = com.test.BlackCar
      red = com.test.RedCar
      com.test.CarWrapper
      com.test.CarWrapper2
      ````

   6. 结果

      ````
      before
      before2
      black
      after2
      after
      ````

      同样对方法进行了增强。这点类似于**静态代理**，不过它能一层一层不停地的包裹，而且是**SPI的配置越靠后，越先执行**，这就像极了Spring里面的AOP

5. **Dubbo自动注入**

   **在dubbo里面是依赖URL来进行自动注入的**

   1. 在原来的接口上新增一个方法，添加`@Adaptive`

      ````java
      @SPI
      public interface CarInterface {
          // 获得颜色
          public void getColor();
          @Adaptive(value = "car")
          public void getColorURL(URL url);
      }
      ````

   2. 新增一个类

      ````java
      public class BenzCar implements CarInterface{
      
          private CarInterface carInterface;
      
          // 注入点
          public void setCarInterface(CarInterface carInterface) {
              this.carInterface = carInterface;
          }
      
          @Override
          public void getColor() {
      
              System.out.println("Benz Car");
          }
      		
          @Override
          public void getColorURL(URL url) {
              System.out.println("do Something~");
              carInterface.getColorURL(url);
          }
      }
      ````

      ````
      black = com.test.BlackCar
      red = com.test.RedCar
      benz = com.test.BenzCar
      # com.test.CarWrapper
      # com.test.CarWrapper2
      ````

   3. 测试

      之前的实现类都相继加上了新的方法
   
      ````java
      public class RedCar implements CarInterface {
          @Override
          public void getColor() {
              System.out.println("red");
          }
      
          @Override
          public void getColorURL(URL url) {
              System.out.println("red url");
          }
   }
      ````
   
      ````java
      ExtensionLoader<CarInterface> extensionLoader =
                      ExtensionLoader.getExtensionLoader(CarInterface.class);
      CarInterface carInterface = extensionLoader.getExtension("benz");
      Map<String, String> map = new HashMap<>();
      map.put("car", "red");
      URL url = new URL("", "", 1, map);
   carInterface.getColorURL(url);
      ````

   4. 结果
   
      ```
      do Something~
   red url
      ```

   5. 结论
   
      其实就是从URL中的Map中获取我们定义好的car开头的服务(`@Adaptive(value = "car")`)，这儿拿到的是实现类`RedCar`，**其实加了`@Adaptive`注解的方法，会在生成的时候被dubbo创建一个代理类，而方法也会被进行增强，其实就是添加了从URL中获取配置的实现类的代码来实现的**

## Dubbo SPI 源码分析

1. 从`ExtensionLoader.getExtensionLoader(CarInterface.class)`看起

   ````java
   public static <T> ExtensionLoader<T> getExtensionLoader(Class<T> type) {
     if (type == null) {
       throw new IllegalArgumentException("Extension type == null");
     }
     if (!type.isInterface()) {
       throw new IllegalArgumentException("Extension type (" + type + ") is not an interface!");
     }
     if (!withExtensionAnnotation(type)) {
       throw new IllegalArgumentException("Extension type (" + type +
                                          ") is not an extension, because it is NOT annotated with @" + SPI.class.getSimpleName() + "!");
     }
     // EXTENSION_LOADERS是一个CurrentHashMap
     ExtensionLoader<T> loader = (ExtensionLoader<T>) EXTENSION_LOADERS.get(type);
     if (loader == null) {
       // 这点代码的功能相当于缓存到本地
       // new ExtensionLoader的时候其实有把被扩展的接口创建一个代理类，如果方法有加@Adaptive注解
       // 就会被增强，添加URL获取属性的实现类的方式
       EXTENSION_LOADERS.putIfAbsent(type, new ExtensionLoader<T>(type));
       loader = (ExtensionLoader<T>) EXTENSION_LOADERS.get(type);
     }
     return loader;
   }
   ````

   **一个接口对应一个ExtensionLoader，同时缓存到本地。**

2. 具体看`extensionLoader.getExtension("benz");`方法

   ````java
   public T getExtension(String name) {
     if (StringUtils.isEmpty(name)) {
       throw new IllegalArgumentException("Extension name == null");
     }
     if ("true".equals(name)) {
       // 返回默认的
       return getDefaultExtension();
     }
     /**
       * holder就是保存数据的封装类，就是为了方便获取，类似于Spring里面的那个BeanDefinitionHolder
       * Holder<Object> holder = cachedInstances.get(name); 
       	ConcurrentMap<String, Holder<Object>> cachedInstances = new ConcurrentHashMap<>();
       	cachedInstances应该是存储缓存的对象
       */
     Holder<Object> holder = getOrCreateHolder(name);
     Object instance = holder.get();
     if (instance == null) {
       synchronized (holder) {
         instance = holder.get();
         if (instance == null) {
           instance = createExtension(name); // 扩展点，实现类
           holder.set(instance);
         }
       }
     }
     return (T) instance;
   }
   ````

   ````java
   public class Holder<T> {
   
       private volatile T value;
   
       public void set(T value) {
           this.value = value;
       }
   
       public T get() {
           return value;
       }
   
   }
   ````

   可见，关键点还是`createExtension()`方法，其他方法无非是作为缓存之用的。

3. `instance = createExtension(name);`

   ````java
   private T createExtension(String name) {
   		// 获取
       Class<?> clazz = getExtensionClasses().get(name);
       if (clazz == null) {
         throw findException(name);
       }
       try {
         T instance = (T) EXTENSION_INSTANCES.get(clazz);
         if (instance == null) {
           EXTENSION_INSTANCES.putIfAbsent(clazz, clazz.newInstance());
           instance = (T) EXTENSION_INSTANCES.get(clazz);
         }
         injectExtension(instance);
         Set<Class<?>> wrapperClasses = cachedWrapperClasses;
         if (CollectionUtils.isNotEmpty(wrapperClasses)) {
           for (Class<?> wrapperClass : wrapperClasses) {
             instance = injectExtension((T) wrapperClass.getConstructor(type).newInstance(instance));
           }
         }
         return instance;
       } catch (Throwable t) {
         throw new IllegalStateException("Extension instance (name: " + name + ", class: " +
                                         type + ") couldn't be instantiated: " + t.getMessage(), t);
       }
     }
   ````

   我们先来看`getExtensionClasses()`方法，但是它的调用链比较长，这儿就不贴代码了，简单总结下，就是：

   1. 读取SPI配置文件中的一行一行的数据，将实现类缓存在一个map里面
   2. 在读取的过程中，如果有加了`@Adapitive`注解的也缓存在一个valotile变量里
   3. 如果实现类的构造方法参数类型和被扩展接口类型一样就判断为`wrapper`类，然后缓存一个hashset里面
   4. 这个方法的调用链里面还有一些小小的验证

   代码继续执行

4. `injectExtension`

   ````java
   private T injectExtension(T instance) {
     try {
       // 这个objectFactory在new Extensionloader的时候调用的
       // objectFactory是这个ExtensionFactory的代理类也就是AdaptiveExtensionFactory，但是它会读取SPI配置文件中，然后生成扩展接口的代理类，其中逻辑如下
       // 1.它会先读取配置文件找到所有的实现类， 如果有实现类加了@Adaptive注解的就把这个类当做该接口的代理类
       // 2.如果没有加了@Adaptive注解的实现类，Dubbo就给你创建一个，这个类也实现了这个接口，类名中有$Adaptive这个字符串
       if (objectFactory != null) {
         for (Method method : instance.getClass().getMethods()) {
           // 如果是setter方法
           if (isSetter(method)) {
             /**
                            * Check {@link DisableInject} to see if we need auto injection for this property
                            */
             if (method.getAnnotation(DisableInject.class) != null) {
               continue;
             }
             // 第一个参数的类型
             Class<?> pt = method.getParameterTypes()[0];
             if (ReflectUtils.isPrimitives(pt)) {
               continue;
             }
             try {
               // 通过方法获取实现类的属性 setCarInterface() -> carInterface
               String property = getSetterProperty(method);
               // pt是被扩展的接口 com.test.CarInterface
               // object就是pt被代理的对象，也就是依赖注入的对象
               // 1.objectFactory是AdaptiveExtensionFactory，上面分析了
               // 2.AdaptiveExtensionFactory里面的getExtension方法其实是调用了父类的另一个实现类SpiExtensionFactory的getExtension方法
               // 3.SpiExtensionFactory的getExtension方法去找pt的代理类，然后返回，就是现在的object
               // 4.SpiExtensionFactory的getExtension没有用到property，而其父类的另一个类SpringExtensionFactory就会使用到
               // 5.因为现在没有用到Spring，所以SpiExtensionFactory没有用
               // 6.所以无论怎么说，object就是pt的代理对象
               // 7.所以最终执行扩展接口的方法，就是执行扩展接口的代理对象对应的方法
               // 8.这就是注入
               Object object = objectFactory.getExtension(pt, property);
               if (object != null) {
                 // 执行set方法，也就是赋值
                 method.invoke(instance, object);
               }
             } catch (Exception e) {
               logger.error("Failed to inject via method " + method.getName()
                            + " of interface " + type.getName() + ": " + e.getMessage(), e);
             }
           }
         }
       }
     } catch (Exception e) {
       logger.error(e.getMessage(), e);
     }
     return instance;
   }
   ````

   上面的`objectFactory`变量如下

   ```java
   ExtensionLoader<CarInterface> extensionLoader =
           ExtensionLoader.getExtensionLoader(CarInterface.class);
   ```

   在这个方法里面创建的

   ````java
   objectFactory =
     (type == ExtensionFactory.class ? null : ExtensionLoader.getExtensionLoader(ExtensionFactory.class).getAdaptiveExtension());
   ````

   **`objectFactory`是`ExtensionFactory`的代理类，其实就是`getAdaptiveExtension()`方法会把我们的扩展接口生成代理类，逻辑如下：**

   1. 读取SPI配置文件，如果里面实现类有`@Adaptive`注解的就把这个类当做该接口的代理类

   2. 如果没有就帮你创建一个类名以`$Adaptive`结尾的类，如下图：

      ![](./img/9.png)

   3. 从图中可以看出，代理类还是实现了接口，方法也是通过Dubbo的SPI去执行，如果接口方法加了`@Adaptive`注解，那么就会从URL去获取对应的参数的实现类，然后在执行方法，如上图中的`getColor()`方法，如果接口上没有加`@Adaptive`，代理类中对应的方法就会加上一段跑出异常的内容，如上图的中的`getSize()`方法。

   `ExtensionFactory`这个类，有默认的实现类，如下，可以认为这个类就是一个`ExtensionFactory`代理实现类

   ````java
   public class AdaptiveExtensionFactory implements ExtensionFactory {
   
       private final List<ExtensionFactory> factories;
   
       public AdaptiveExtensionFactory() {
           ExtensionLoader<ExtensionFactory> loader = ExtensionLoader.getExtensionLoader(ExtensionFactory.class);
           List<ExtensionFactory> list = new ArrayList<ExtensionFactory>();
           for (String name : loader.getSupportedExtensions()) {
               list.add(loader.getExtension(name));
           }
           factories = Collections.unmodifiableList(list);
       }
   
       @Override
       public <T> T getExtension(Class<T> type, String name) {
           for (ExtensionFactory factory : factories) {
               T extension = factory.getExtension(type, name);
               if (extension != null) {
                   return extension;
               }
           }
           return null;
       }
   
   }
   ````

   **所以`objectFactory`就是这个`ExtensionFactory`的代理类`AdaptiveExtensionFactory`**

   `Object object = objectFactory.getExtension(pt, property);`

   这段代码很复杂，下面我把注释贴出来

   ````java
   // 通过方法获取实现类的属性 setCarInterface() -> carInterface
   String property = getSetterProperty(method);
   // pt是被扩展的接口 com.test.CarInterface
   // object就是pt被代理的对象，也就是依赖注入的对象
   // 1.objectFactory是AdaptiveExtensionFactory，上面分析了
   // 2.AdaptiveExtensionFactory里面的getExtension方法其实是调用了父类的另一个实现类SpiExtensionFactory的getExtension方法
   // 3.SpiExtensionFactory的getExtension方法去找pt的代理类，然后返回，就是现在的object
   // 4.SpiExtensionFactory的getExtension没有用到property，而其父类的另一个类SpringExtensionFactory就会使用到
   // 5.因为现在没有用到Spring，所以SpiExtensionFactory没有用
   // 6.所以无论怎么说，object就是pt的代理对象
   // 7.所以最终执行扩展接口的方法，就是执行扩展接口的代理对象的方法
   // 8.这就是注入
   Object object = objectFactory.getExtension(pt, property);
   if (object != null) {
     // 执行set方法，也就是赋值
     method.invoke(instance, object);
   }
   ````

   **其实注入就是将被扩展接口的代理类注入到实现类里面，因为被扩展接口的代理类的方法加了`@Adaptive`注解就会去从URL中获取`@Adaptive`的值对应的实现类的key，然后通过SPI的方式去配置文件中获取对应的实现类，然后实例化，执行方法，这样就完成了Dubbo的自动注入**


## Dubbo API

### 􏰫􏰬􏰭URL

统一资源定位器

### 标准的URL格式

`protocol://username:password@host:port/path?key=value&key=value`

 参数可以理解为使用这个资源的参数，其实就是配置信息

### Dubbo中的URL

在Dubbo中：

+ 服务是资源，dubbo://192.168.1.6:20880/com.luban.HelloService?timeout=3000
+ 注册中心是资源：zookeeper://127.0.0.1:2181/org.apache.dubbo.registry.RegistryService? application=democonsumer&dubbo=2.0.2&interface=org.apache.dubbo.registry.RegistryService&pid=1214&qos.po rt=33333×tamp=1545721981946
+ 消费者是资源：consumer://30.5.120.217/org.apache.dubbo.demo.DemoService? application=demoA$I R1@DPJ(3   0/ -L   consumer&category=consumers&check=false&dubbo=2.0.2&interface=org.apache.dubbo.demo. DemoService&methods=sayHello&pid=1209&qos.port=33333&side=consumer×tamp=1545 721827784
+ 配置信息是资源
+ 元数据信息是资源
+ 万物皆资源，皆可用URL表示􏰀􏰁􏰂􏰃􏰄􏰅􏰆􏰀􏰁􏰂􏰃􏰄􏰅􏰆􏰀􏰁􏰂􏰃􏰄􏰅􏰆􏰀􏰁􏰂􏰃􏰄􏰅􏰆􏰀􏰁􏰂􏰃􏰄􏰅􏰆􏰀􏰁􏰂􏰃􏰄􏰅􏰆􏰀􏰁􏰂􏰃􏰄􏰅􏰆􏰀􏰁􏰂􏰃􏰄􏰅􏰆􏰀􏰁􏰂􏰃􏰄􏰅􏰆􏰀􏰁􏰂􏰃􏰄􏰅􏰆􏰀􏰁􏰂􏰃􏰄􏰅􏰆􏰀􏰁􏰂􏰃􏰄􏰅􏰆􏰀􏰁􏰂􏰃􏰄􏰅􏰆􏰀􏰁􏰂􏰃􏰄􏰅􏰆􏰀􏰁􏰂􏰃􏰄􏰅􏰆

我们用`<dubbo:service interface="com.luban.dubbo_vip_xml_demo.api.HelloService"
ref="helloService"/>`定义一个服务器，那么spring会把dubbo的标签解析成Bean对象，在服务暴露初始化时，将Bean对象转换URL格式，所以Bean属性转化成URL的参数。

对于dubbo中的URL，有人理解为配置总线，有人理解为统一配置模型，说法虽然不同，但都在表达一个意思，这样的URL在dubbo中被当做是公共契约，URL作为上下文信息贯穿整个框架。

### Invoker

Invoker是Dubbo的核心模型，代表一个可执行体。在服务提供方，Invoker用于调用服务提供类。在服务消费方，Invoker用于执行远程调用。

### Invocation

调用对象

### Java SPI

上面有解释

### Dubbo API

上面也有详细说明

### `@SPI`

修饰在接口上，注解的值代表的该接口默认的扩展点名。

### `@Adaptive`

可以修饰在类和接口的方法上。

1. 当修饰在类上时，表示该类为所实现的接口的代理类实现
2. 当修饰在接口方法上，一般是没有人工的代理类实现，需要依赖Dubbo自动生成代理类，而这个代理类所对应的实例在调用某个方法时，如果这个方法被`@Adaptive`修饰了，则会从URL中取值作为扩展点名去加载实现类并实例化，最后再使用这个实例调用对应的方法，`@Adaptive`的值一般就是在这个场景中才有用，用来指定可以从URL中的哪个key可以获取到值。

## 总结

其实Dubbo的可扩展机制就是基于Java SPI的另一种方式，通过读取key/value形式的配置类，将实现类实例化即可，但是dubbo的自动注入即实现类中加了set方法是通过生成被扩展接口的代理类，然后将代理类set进它的实现类里面完成了自动注入（因为dubbo创建的代理类会将扩展接口中加了@Adaptive方法对应的实现类从URL中找到），也就是对Dubbo进行了服务扩展，这就是Dubbo的可扩展机制。