上回说到在Spring启动的时候会注册六个类到`BeanDefinitionMap`里面，其中最重要的就是`ConfigurationClassPostProcessor`，其中比较重要的方法就是`processConfigBeanDefinitions()`方法，此方法在上下文调用`refresh()`方法的时候，在`invokeBeanFactoryPostProcessors(beanFactory);`这个方法里面的

````java
/**
 * 这个方法很重要，主要是去执行spring内置的processors和我们自定义的processors，以及扫描包
 * 扫描包很重要
 * 比如我们引入了一个扫描类，它会去解析是否加了@Configurtion，@Service，@Compent，@Import注解
 * 如果加了会去解析，如果有扫描包的配置还会去扫描包
 */
invokeBeanFactoryPostProcessors(beanFactory);
````

然后是

````java
protected void invokeBeanFactoryPostProcessors(ConfigurableListableBeanFactory beanFactory) {
		/**
		 *  这个地方需要注意getBeanFactoryPostProcessors()是获取手动给spring的BeanFactoryPostProcessors
		 *  这儿的自定义不仅仅是程序员自己写的，自己写的可以加@Compoent也可以不加
		 *  如果加了这个地方得不到的，为什么得不到？
		 *  因为getBeanFactoryPostProcessors()是获取ApplicationContext自己定义的一个list
		 *  初始化的时候并没有赋过值，所以获取不到
		 *  只有通过ApplicationContext.addBeanFactoryPostProcessor（new 我们自己定义的），
		 *  这儿才能获取得到
		 */
    PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors(beanFactory, getBeanFactoryPostProcessors());

		// Detect a LoadTimeWeaver and prepare for weaving, if found in the meantime
		// (e.g. through an @Bean method registered by ConfigurationClassPostProcessor)
    if (beanFactory.getTempClassLoader() == null && beanFactory.containsBean(LOAD_TIME_WEAVER_BEAN_NAME)) {
        beanFactory.addBeanPostProcessor(new LoadTimeWeaverAwareProcessor(beanFactory));
        beanFactory.setTempClassLoader(new ContextTypeMatchClassLoader(beanFactory.getBeanClassLoader()));
    }
}
````

`invokeBeanFactoryPostProcessors`方法

````java
public static void invokeBeanFactoryPostProcessors(
			ConfigurableListableBeanFactory beanFactory, List<BeanFactoryPostProcessor> beanFactoryPostProcessors) {

    // Invoke BeanDefinitionRegistryPostProcessors first, if any.
    Set<String> processedBeans = new HashSet<>();

    if (beanFactory instanceof BeanDefinitionRegistry) {
        BeanDefinitionRegistry registry = (BeanDefinitionRegistry) beanFactory;
        /**
			 * 定义两个list,因为spring并不知道到底实现了BeanFactoryPostProcessor还是BeanDefinitionRegistryPostProcessor
 			 */
        List<BeanFactoryPostProcessor> regularPostProcessors = new ArrayList<>();
        List<BeanDefinitionRegistryPostProcessor> registryProcessors = new ArrayList<>();

        for (BeanFactoryPostProcessor postProcessor : beanFactoryPostProcessors) {
            if (postProcessor instanceof BeanDefinitionRegistryPostProcessor) {
                BeanDefinitionRegistryPostProcessor registryProcessor =
                    (BeanDefinitionRegistryPostProcessor) postProcessor;
                registryProcessor.postProcessBeanDefinitionRegistry(registry);
                registryProcessors.add(registryProcessor);
            } else {
                regularPostProcessors.add(postProcessor);
            }
        }

        // Do not initialize FactoryBeans here: We need to leave all regular beans
        // uninitialized to let the bean factory post-processors apply to them!
        // Separate between BeanDefinitionRegistryPostProcessors that implement
        // PriorityOrdered, Ordered, and the rest.
        /**
		 * currentRegistryProcessors放的是spring内部实现了BeanDefinitionRegistryPostProcessor的类
		 */
        List<BeanDefinitionRegistryPostProcessor> currentRegistryProcessors = new ArrayList<>();

        // First, invoke the BeanDefinitionRegistryPostProcessors that implement PriorityOrdered.
        // 根据Bean的类型去beanDefinitionMap里面中获取bean的名字
        // 这儿是ConfigurationClassProcessor类，只有一个
        String[] postProcessorNames =
            beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, true, false);
        for (String ppName : postProcessorNames) {
            if (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) {
                currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));
                processedBeans.add(ppName);
            }
        }
        // 排序
        sortPostProcessors(currentRegistryProcessors, beanFactory);
        // 合并
        registryProcessors.addAll(currentRegistryProcessors);
        // 最重要，注意这里是方法调用
        invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry);
        // 这儿list只是一个临时变量
        currentRegistryProcessors.clear();

        // Next, invoke the BeanDefinitionRegistryPostProcessors that implement Ordered.
        postProcessorNames = beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, true, false);
        for (String ppName : postProcessorNames) {
            if (!processedBeans.contains(ppName) && beanFactory.isTypeMatch(ppName, Ordered.class)) {
                currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));
                processedBeans.add(ppName);
            }
        }
        sortPostProcessors(currentRegistryProcessors, beanFactory);
        registryProcessors.addAll(currentRegistryProcessors);
        invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry);
        currentRegistryProcessors.clear();

        // Finally, invoke all other BeanDefinitionRegistryPostProcessors until no further ones appear.
        boolean reiterate = true;
        while (reiterate) {
            reiterate = false;
            postProcessorNames = beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, true, false);
            for (String ppName : postProcessorNames) {
                if (!processedBeans.contains(ppName)) {
                    currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));
                    processedBeans.add(ppName);
                    reiterate = true;
                }
            }
            sortPostProcessors(currentRegistryProcessors, beanFactory);
            registryProcessors.addAll(currentRegistryProcessors);
            invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry);
            currentRegistryProcessors.clear();
        }

        // Now, invoke the postProcessBeanFactory callback of all processors handled so far.
        invokeBeanFactoryPostProcessors(registryProcessors, beanFactory);
        invokeBeanFactoryPostProcessors(regularPostProcessors, beanFactory);
    }

    else {
        // Invoke factory processors registered with the context instance.
        invokeBeanFactoryPostProcessors(beanFactoryPostProcessors, beanFactory);
    }

    // Do not initialize FactoryBeans here: We need to leave all regular beans
    // uninitialized to let the bean factory post-processors apply to them!
    String[] postProcessorNames =
        beanFactory.getBeanNamesForType(BeanFactoryPostProcessor.class, true, false);

    // Separate between BeanFactoryPostProcessors that implement PriorityOrdered,
    // Ordered, and the rest.
    List<BeanFactoryPostProcessor> priorityOrderedPostProcessors = new ArrayList<>();
    List<String> orderedPostProcessorNames = new ArrayList<>();
    List<String> nonOrderedPostProcessorNames = new ArrayList<>();
    for (String ppName : postProcessorNames) {
        if (processedBeans.contains(ppName)) {
            // skip - already processed in first phase above
        }
        else if (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) {
            priorityOrderedPostProcessors.add(beanFactory.getBean(ppName, BeanFactoryPostProcessor.class));
        }
        else if (beanFactory.isTypeMatch(ppName, Ordered.class)) {
            orderedPostProcessorNames.add(ppName);
        }
        else {
            nonOrderedPostProcessorNames.add(ppName);
        }
    }

    // First, invoke the BeanFactoryPostProcessors that implement PriorityOrdered.
    sortPostProcessors(priorityOrderedPostProcessors, beanFactory);
    invokeBeanFactoryPostProcessors(priorityOrderedPostProcessors, beanFactory);

    // Next, invoke the BeanFactoryPostProcessors that implement Ordered.
    List<BeanFactoryPostProcessor> orderedPostProcessors = new ArrayList<>();
    for (String postProcessorName : orderedPostProcessorNames) {
        orderedPostProcessors.add(beanFactory.getBean(postProcessorName, BeanFactoryPostProcessor.class));
    }
    sortPostProcessors(orderedPostProcessors, beanFactory);
    invokeBeanFactoryPostProcessors(orderedPostProcessors, beanFactory);

    // Finally, invoke all other BeanFactoryPostProcessors.
    List<BeanFactoryPostProcessor> nonOrderedPostProcessors = new ArrayList<>();
    for (String postProcessorName : nonOrderedPostProcessorNames) {
        nonOrderedPostProcessors.add(beanFactory.getBean(postProcessorName, BeanFactoryPostProcessor.class));
    }
    invokeBeanFactoryPostProcessors(nonOrderedPostProcessors, beanFactory);

    // Clear cached merged bean definitions since the post-processors might have
    // modified the original metadata, e.g. replacing placeholders in values...
    beanFactory.clearMetadataCache();
}
````

`invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry);`

````java
public void processConfigBeanDefinitions(BeanDefinitionRegistry registry) {
    // app 提供的bean
    List<BeanDefinitionHolder> configCandidates = new ArrayList<>();
    // 获取容器中注册的所有bean名字，这儿主要有7个，spring默认有6个，咱们自己写了一个
    String[] candidateNames = registry.getBeanDefinitionNames();

    for (String beanName : candidateNames) {
        // 通过beanName获取BeanDefinition
        BeanDefinition beanDef = registry.getBeanDefinition(beanName);
        // 如果BeanDefinition中的ConfigurationClass属性为full或者lite，则意味着已经处理过了，直接跳过
        if (ConfigurationClassUtils.isFullConfigurationClass(beanDef) ||
            ConfigurationClassUtils.isLiteConfigurationClass(beanDef)) {
            // 这里需要结合下面的代码才能理解
            if (logger.isDebugEnabled()) {
                logger.debug("Bean definition has already been processed as a configuration class: " + beanDef);
            }
            // 判断是否是Configuration类，如果加了下面判断@Component和@Import的几个注解就不在判断
        } else if (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory)) {
            configCandidates.add(new BeanDefinitionHolder(beanDef, beanName));
        }
    }

    // Return immediately if no @Configuration classes were found
    if (configCandidates.isEmpty()) {
        return;
    }

    // Sort by previously determined @Order value, if applicable
    // 排序，如果有order
    configCandidates.sort((bd1, bd2) -> {
        int i1 = ConfigurationClassUtils.getOrder(bd1.getBeanDefinition());
        int i2 = ConfigurationClassUtils.getOrder(bd2.getBeanDefinition());
        return Integer.compare(i1, i2);
    });

    // Detect any custom bean name generation strategy supplied through the enclosing application context
    SingletonBeanRegistry sbr = null;
    if (registry instanceof SingletonBeanRegistry) {
        sbr = (SingletonBeanRegistry) registry;
        if (!this.localBeanNameGeneratorSet) {
            BeanNameGenerator generator = (BeanNameGenerator) sbr.getSingleton(CONFIGURATION_BEAN_NAME_GENERATOR);
            if (generator != null) {
                this.componentScanBeanNameGenerator = generator;
                this.importBeanNameGenerator = generator;
            }
        }
    }

    if (this.environment == null) {
        this.environment = new StandardEnvironment();
    }

    // Parse each @Configuration class
    ConfigurationClassParser parser = new ConfigurationClassParser(
        this.metadataReaderFactory, this.problemReporter, this.environment,
        this.resourceLoader, this.componentScanBeanNameGenerator, registry);

    Set<BeanDefinitionHolder> candidates = new LinkedHashSet<>(configCandidates);
    Set<ConfigurationClass> alreadyParsed = new HashSet<>(configCandidates.size());
    do {
        // 重要方法 解析标注@Configuration注解的类
        parser.parse(candidates);
        parser.validate();

        Set<ConfigurationClass> configClasses = new LinkedHashSet<>(parser.getConfigurationClasses());
        configClasses.removeAll(alreadyParsed);

        // Read the model and create bean definitions based on its content
        if (this.reader == null) {
            this.reader = new ConfigurationClassBeanDefinitionReader(
                registry, this.sourceExtractor, this.resourceLoader, this.environment,
                this.importBeanNameGenerator, parser.getImportRegistry());
        }
        this.reader.loadBeanDefinitions(configClasses);
        alreadyParsed.addAll(configClasses);

        candidates.clear();
        if (registry.getBeanDefinitionCount() > candidateNames.length) {
            String[] newCandidateNames = registry.getBeanDefinitionNames();
            Set<String> oldCandidateNames = new HashSet<>(Arrays.asList(candidateNames));
            Set<String> alreadyParsedClasses = new HashSet<>();
            for (ConfigurationClass configurationClass : alreadyParsed) {
                alreadyParsedClasses.add(configurationClass.getMetadata().getClassName());
            }
            for (String candidateName : newCandidateNames) {
                if (!oldCandidateNames.contains(candidateName)) {
                    BeanDefinition bd = registry.getBeanDefinition(candidateName);
                    if (ConfigurationClassUtils.checkConfigurationClassCandidate(bd, this.metadataReaderFactory) &&
                        !alreadyParsedClasses.contains(bd.getBeanClassName())) {
                        candidates.add(new BeanDefinitionHolder(bd, candidateName));
                    }
                }
            }
            candidateNames = newCandidateNames;
        }
    }
    while (!candidates.isEmpty());

    // Register the ImportRegistry as a bean in order to support ImportAware @Configuration classes
    if (sbr != null && !sbr.containsSingleton(IMPORT_REGISTRY_BEAN_NAME)) {
        sbr.registerSingleton(IMPORT_REGISTRY_BEAN_NAME, parser.getImportRegistry());
    }

    if (this.metadataReaderFactory instanceof CachingMetadataReaderFactory) {
        // Clear cache in externally provided MetadataReaderFactory; this is a no-op
        // for a shared cache since it'll be cleared by the ApplicationContext.
        ((CachingMetadataReaderFactory) this.metadataReaderFactory).clearCache();
    }
}
````

其中最重要的就是`parser.parse(candidates);`方法

````java
/***
* 解析方法，比如扫描ComponentSacn标注的包下面的所有类
* @param configCandidates 传入的是加了@Configuration注解的Set集合
*/
public void parse(Set<BeanDefinitionHolder> configCandidates) {
    this.deferredImportSelectors = new LinkedList<>();

    for (BeanDefinitionHolder holder : configCandidates) {
        BeanDefinition bd = holder.getBeanDefinition();
        try {
            // 如果bd是AnnotatedBeanDefinition则执行此方法
            if (bd instanceof AnnotatedBeanDefinition) {
                parse(((AnnotatedBeanDefinition) bd).getMetadata(), holder.getBeanName());
            }
            else if (bd instanceof AbstractBeanDefinition && ((AbstractBeanDefinition) bd).hasBeanClass()) {
                parse(((AbstractBeanDefinition) bd).getBeanClass(), holder.getBeanName());
            }
            else {
                parse(bd.getBeanClassName(), holder.getBeanName());
            }
        }
        catch (BeanDefinitionStoreException ex) {
            throw ex;
        }
        catch (Throwable ex) {
            throw new BeanDefinitionStoreException(
                "Failed to parse configuration class [" + bd.getBeanClassName() + "]", ex);
        }
    }

    processDeferredImportSelectors();
}
````

我们传入的`Java Config`类是`Annotated`，即是加了注解的，所以这儿调用下面的方法

````java
protected final void parse(AnnotationMetadata metadata, String beanName) throws IOException {
    processConfigurationClass(new ConfigurationClass(metadata, beanName));
}
````

````java
protected void processConfigurationClass(ConfigurationClass configClass) throws IOException {
    if (this.conditionEvaluator.shouldSkip(configClass.getMetadata(), ConfigurationPhase.PARSE_CONFIGURATION)) {
        return;
    }

    ConfigurationClass existingClass = this.configurationClasses.get(configClass);
    if (existingClass != null) {
        if (configClass.isImported()) {
            if (existingClass.isImported()) {
                existingClass.mergeImportedBy(configClass);
            }
            // Otherwise ignore new imported config class; existing non-imported class overrides it.
            return;
        }
        else {
            // Explicit bean definition found, probably replacing an import.
            // Let's remove the old one and go with the new one.
            this.configurationClasses.remove(configClass);
            this.knownSuperclasses.values().removeIf(configClass::equals);
        }
    }

    // Recursively process the configuration class and its superclass hierarchy.
    // 封装成SourceClass对象
    SourceClass sourceClass = asSourceClass(configClass);
    do {
        
        sourceClass = doProcessConfigurationClass(configClass, sourceClass);
    }
    while (sourceClass != null);

    this.configurationClasses.put(configClass, configClass);
}
````

`doProcessConfigurationClass(configClass, sourceClass);`

````java
protected final SourceClass doProcessConfigurationClass(ConfigurationClass configClass, SourceClass sourceClass)
			throws IOException {

		// Recursively process any member (nested) classes first
		processMemberClasses(configClass, sourceClass);

		// Process any @PropertySource annotations
		for (AnnotationAttributes propertySource : AnnotationConfigUtils.attributesForRepeatable(
				sourceClass.getMetadata(), PropertySources.class,
				org.springframework.context.annotation.PropertySource.class)) {
			if (this.environment instanceof ConfigurableEnvironment) {
				processPropertySource(propertySource);
			}
			else {
				logger.warn("Ignoring @PropertySource annotation on [" + sourceClass.getMetadata().getClassName() +
						"]. Reason: Environment must implement ConfigurableEnvironment");
			}
		}

		// Process any @ComponentScan annotations
		Set<AnnotationAttributes> componentScans = AnnotationConfigUtils.attributesForRepeatable(
				sourceClass.getMetadata(), ComponentScans.class, ComponentScan.class);
		if (!componentScans.isEmpty() &&
				!this.conditionEvaluator.shouldSkip(sourceClass.getMetadata(), ConfigurationPhase.REGISTER_BEAN)) {
			for (AnnotationAttributes componentScan : componentScans) {
				// The config class is annotated with @ComponentScan -> perform the scan immediately
				// @Configuration加了@ComponentScan注解 执行扫描
				Set<BeanDefinitionHolder> scannedBeanDefinitions =
						this.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName());
				// Check the set of scanned definitions for any further config classes and parse recursively if needed
				for (BeanDefinitionHolder holder : scannedBeanDefinitions) {
					BeanDefinition bdCand = holder.getBeanDefinition().getOriginatingBeanDefinition();
					if (bdCand == null) {
						bdCand = holder.getBeanDefinition();
					}
					if (ConfigurationClassUtils.checkConfigurationClassCandidate(bdCand, this.metadataReaderFactory)) {
                        // 这个方法
						parse(bdCand.getBeanClassName(), holder.getBeanName());
					}
				}
			}
		}

		// Process any @Import annotations
		// 处理加了@Import注解
		processImports(configClass, sourceClass, getImports(sourceClass), true);

		// Process any @ImportResource annotations
		// 处理加了@ImportResource注解
		AnnotationAttributes importResource =
				AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ImportResource.class);
		if (importResource != null) {
			String[] resources = importResource.getStringArray("locations");
			Class<? extends BeanDefinitionReader> readerClass = importResource.getClass("reader");
			for (String resource : resources) {
				String resolvedResource = this.environment.resolveRequiredPlaceholders(resource);
				configClass.addImportedResource(resolvedResource, readerClass);
			}
		}

		// Process individual @Bean methods
		Set<MethodMetadata> beanMethods = retrieveBeanMethodMetadata(sourceClass);
		for (MethodMetadata methodMetadata : beanMethods) {
			configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass));
		}

		// Process default methods on interfaces
		processInterfaces(configClass, sourceClass);

		// Process superclass, if any
		if (sourceClass.getMetadata().hasSuperClass()) {
			String superclass = sourceClass.getMetadata().getSuperClassName();
			if (superclass != null && !superclass.startsWith("java") &&
					!this.knownSuperclasses.containsKey(superclass)) {
				this.knownSuperclasses.put(superclass, configClass);
				// Superclass found, return its annotation metadata and recurse
				return sourceClass.getSuperClass();
			}
		}

		// No superclass -> processing is complete
		return null;
}
````

`Set<BeanDefinitionHolder> scannedBeanDefinitions=this.componentScanParser.parse() `

这个方法去扫描加了@CompoentScan的类，核心方法是

````java
public Set<BeanDefinitionHolder> parse(AnnotationAttributes componentScan, final String declaringClass) {
		ClassPathBeanDefinitionScanner scanner = new ClassPathBeanDefinitionScanner(this.registry,
				componentScan.getBoolean("useDefaultFilters"), this.environment, this.resourceLoader);

		Class<? extends BeanNameGenerator> generatorClass = componentScan.getClass("nameGenerator");
		boolean useInheritedGenerator = (BeanNameGenerator.class == generatorClass);
		scanner.setBeanNameGenerator(useInheritedGenerator ? this.beanNameGenerator :
				BeanUtils.instantiateClass(generatorClass));

		ScopedProxyMode scopedProxyMode = componentScan.getEnum("scopedProxy");
		if (scopedProxyMode != ScopedProxyMode.DEFAULT) {
			scanner.setScopedProxyMode(scopedProxyMode);
		}
		else {
			Class<? extends ScopeMetadataResolver> resolverClass = componentScan.getClass("scopeResolver");
			scanner.setScopeMetadataResolver(BeanUtils.instantiateClass(resolverClass));
		}

		scanner.setResourcePattern(componentScan.getString("resourcePattern"));

		for (AnnotationAttributes filter : componentScan.getAnnotationArray("includeFilters")) {
			for (TypeFilter typeFilter : typeFiltersFor(filter)) {
				scanner.addIncludeFilter(typeFilter);
			}
		}
		for (AnnotationAttributes filter : componentScan.getAnnotationArray("excludeFilters")) {
			for (TypeFilter typeFilter : typeFiltersFor(filter)) {
				scanner.addExcludeFilter(typeFilter);
			}
		}

		boolean lazyInit = componentScan.getBoolean("lazyInit");
		if (lazyInit) {
			scanner.getBeanDefinitionDefaults().setLazyInit(true);
		}

		Set<String> basePackages = new LinkedHashSet<>();
		String[] basePackagesArray = componentScan.getStringArray("basePackages");
		for (String pkg : basePackagesArray) {
			String[] tokenized = StringUtils.tokenizeToStringArray(this.environment.resolvePlaceholders(pkg),
					ConfigurableApplicationContext.CONFIG_LOCATION_DELIMITERS);
			Collections.addAll(basePackages, tokenized);
		}
		for (Class<?> clazz : componentScan.getClassArray("basePackageClasses")) {
			basePackages.add(ClassUtils.getPackageName(clazz));
		}
		if (basePackages.isEmpty()) {
			basePackages.add(ClassUtils.getPackageName(declaringClass));
		}

		scanner.addExcludeFilter(new AbstractTypeHierarchyTraversingFilter(false, false) {
			@Override
			protected boolean matchClassName(String className) {
				return declaringClass.equals(className);
			}
		});
		return scanner.doScan(StringUtils.toStringArray(basePackages));
	}
````

`return scanner.doScan(StringUtils.toStringArray(basePackages));`

````java
protected Set<BeanDefinitionHolder> doScan(String... basePackages) {
    Assert.notEmpty(basePackages, "At least one base package must be specified");
    Set<BeanDefinitionHolder> beanDefinitions = new LinkedHashSet<>();
    // 开始扫描
    for (String basePackage : basePackages) {
        // 扫描basePackage路径下的java文件
        // 符合条件的并把它转成BeanDefinition类型
        Set<BeanDefinition> candidates = findCandidateComponents(basePackage);
        for (BeanDefinition candidate : candidates) {
            ScopeMetadata scopeMetadata = this.scopeMetadataResolver.resolveScopeMetadata(candidate);
            candidate.setScope(scopeMetadata.getScopeName());
            String beanName = this.beanNameGenerator.generateBeanName(candidate, this.registry);
            if (candidate instanceof AbstractBeanDefinition) {
                // 如果这个类是AbstratBeanDefinition的子类
                // 则为它设置默认值，比如lazy，init，destory等属性
                postProcessBeanDefinition((AbstractBeanDefinition) candidate, beanName);
            }
            if (candidate instanceof AnnotatedBeanDefinition) {

                // 检查并且处理常用的注解
                // 这里的处理主要是指把常用的注解的值设置到AnnotatedBeanDefinition当中
                // 当前前提是这个类必须是AnnotatedBeanDefinition类型的，说白了就是加了注解的类
                AnnotationConfigUtils.processCommonDefinitionAnnotations((AnnotatedBeanDefinition) candidate);
            }
            if (checkCandidate(beanName, candidate)) {
                BeanDefinitionHolder definitionHolder = new BeanDefinitionHolder(candidate, beanName);
                definitionHolder =
                    AnnotationConfigUtils.applyScopedProxyMode(scopeMetadata, definitionHolder, this.registry);
                beanDefinitions.add(definitionHolder);
                // 加入到map当中
                registerBeanDefinition(definitionHolder, this.registry);
            }
        }
    }
    return beanDefinitions;
}
````

上面的`doScan`就是扫描普通类，即加了@Component的类，并且为它们设置默认属性，然后放到了map里面

接下来我们看它是怎么处理@Import注解的，在`doProcessConfigurationClass`里面的`processImports(configClass, sourceClass, getImports(sourceClass), true);`方法

接下来我们来探究他就是怎么把我们importSelector类中的字符串生成的类放入我们的beanDefinitionMap里面

````java
// 上面的代码完成了普通类的扫描，即加了@Component的类
// 这里处理的@import是需要判断我们的类当中时候有@Import注解
// 如果有就把@Import当中的值拿出来，这是一个类
// 比如@Import(xxx.class) 这里便把xx传进去进行解析
// 在解析过程中如果发觉是一个importSelector那么久回调selector的方法
// 返回一个字符串数组，遍历，得到类，继而在递归调用本方法来处理这个类
// 判断一组类是不是Import?(3中Import) getImports(sourceClass)中已经获取了Import中的类
//
// Process any @Import annotations
// 处理加了@Import注解
processImports(configClass, sourceClass, getImports(sourceClass), true);
````

````java
private void processImports(ConfigurationClass configClass, SourceClass currentSourceClass,
			Collection<SourceClass> importCandidates, boolean checkForCircularImports) {

		if (importCandidates.isEmpty()) {
			return;
		}

		if (checkForCircularImports && isChainedImportOnStack(configClass)) {
			this.problemReporter.error(new CircularImportProblem(configClass, this.importStack));
		}
		else {
			this.importStack.push(configClass);
			try {
				for (SourceClass candidate : importCandidates) {
					// 判断是否import了ImportSelector的类
					if (candidate.isAssignable(ImportSelector.class)) {
						// Candidate class is an ImportSelector -> delegate to it to determine imports
						Class<?> candidateClass = candidate.loadClass();
						ImportSelector selector = BeanUtils.instantiateClass(candidateClass, ImportSelector.class);
						ParserStrategyUtils.invokeAwareMethods(
								selector, this.environment, this.resourceLoader, this.registry);
						if (this.deferredImportSelectors != null && selector instanceof DeferredImportSelector) {
							this.deferredImportSelectors.add(
									new DeferredImportSelectorHolder(configClass, (DeferredImportSelector) selector));
						}
						else {
							// 回调
							String[] importClassNames = selector.selectImports(currentSourceClass.getMetadata());
							// 获取字符串中的class
							Collection<SourceClass> importSourceClasses = asSourceClasses(importClassNames);
							// 递归处理，如果获取字符串中的class也可能加了@Import注解
							processImports(configClass, currentSourceClass, importSourceClasses, false);
						}
					}
					/**
					 * 很重要
					 * 判断是否@import了ImportBeanDefinitionRegistrar类
					 */
					else if (candidate.isAssignable(ImportBeanDefinitionRegistrar.class)) {
						// Candidate class is an ImportBeanDefinitionRegistrar ->
						// delegate to it to register additional bean definitions
						Class<?> candidateClass = candidate.loadClass();
						ImportBeanDefinitionRegistrar registrar =
								BeanUtils.instantiateClass(candidateClass, ImportBeanDefinitionRegistrar.class);
						ParserStrategyUtils.invokeAwareMethods(
								registrar, this.environment, this.resourceLoader, this.registry);
					  // 放进configClass当中 也是一个map	
                        configClass.addImportBeanDefinitionRegistrar(registrar, currentSourceClass.getMetadata());
					}
					else {
						// Candidate class not an ImportSelector or ImportBeanDefinitionRegistrar ->
						// process it as an @Configuration class
						// 处理普通类，即加了类似于@Configuration的类
                         // 先放进map，之后再注册
						this.importStack.registerImport(
								currentSourceClass.getMetadata(), candidate.getMetadata().getClassName());
                       	 // 放进一个map之后注册
						processConfigurationClass(candidate.asConfigClass(configClass));
					}
				}
			}
			catch (BeanDefinitionStoreException ex) {
				throw ex;
			}
			catch (Throwable ex) {
				throw new BeanDefinitionStoreException(
						"Failed to process import candidates for configuration class [" +
						configClass.getMetadata().getClassName() + "]", ex);
			}
			finally {
				this.importStack.pop();
			}
		}
````

````java
protected void processConfigurationClass(ConfigurationClass configClass) throws IOException {
		if (this.conditionEvaluator.shouldSkip(configClass.getMetadata(), ConfigurationPhase.PARSE_CONFIGURATION)) {
			return;
		}

		ConfigurationClass existingClass = this.configurationClasses.get(configClass);
		if (existingClass != null) {
			if (configClass.isImported()) {
				if (existingClass.isImported()) {
					existingClass.mergeImportedBy(configClass);
				}
				// Otherwise ignore new imported config class; existing non-imported class overrides it.
				return;
			}
			else {
				// Explicit bean definition found, probably replacing an import.
				// Let's remove the old one and go with the new one.
				this.configurationClasses.remove(configClass);
				this.knownSuperclasses.values().removeIf(configClass::equals);
			}
		}

		// Recursively process the configuration class and its superclass hierarchy.
		// 封装成SourceClass对象
		SourceClass sourceClass = asSourceClass(configClass);
		do {
			sourceClass = doProcessConfigurationClass(configClass, sourceClass);
		}
		while (sourceClass != null);
		// 最后放进map里面
		// configurationClasses是一个集合，会在后面拿出来解析成bd然后注册
		// 而普通类在扫描出来的时候就被注册了，如果是ImportSelector，会先放到configurationClasses中后面再进行注册
		this.configurationClasses.put(configClass, configClass);
	}
````

放进Map里面，然后在之前的方法里面进行验证，然后获取

```java
parser.validate();

			Set<ConfigurationClass> configClasses = new LinkedHashSet<>(parser.getConfigurationClasses());
			configClasses.removeAll(alreadyParsed);
```

如果是`ImportBeanDefinitionRegistrar`类也是先放进一个`ConfigClass`的map里面，然后在下面的方法处理再注册

````java
private void loadBeanDefinitionsForConfigurationClass(
			ConfigurationClass configClass, TrackedConditionEvaluator trackedConditionEvaluator) {

  if (trackedConditionEvaluator.shouldSkip(configClass)) {
    String beanName = configClass.getBeanName();
    // 如果包含了就删除
    if (StringUtils.hasLength(beanName) && this.registry.containsBeanDefinition(beanName)) {
      this.registry.removeBeanDefinition(beanName);
    }
    this.importRegistry.removeImportingClass(configClass.getMetadata().getClassName());
    return;
  }
  // 如果被impot 会被spring标注
  if (configClass.isImported()) {
    registerBeanDefinitionForImportedConfigurationClass(configClass);
  }
  // @Bean方法 
  for (BeanMethod beanMethod : configClass.getBeanMethods()) {
    loadBeanDefinitionsForBeanMethod(beanMethod);
  }
  // 处理Import的xml
  loadBeanDefinitionsFromImportedResources(configClass.getImportedResources());
  // 注册ImportBeanDefinitionRegistrars
  loadBeanDefinitionsFromRegistrars(configClass.getImportBeanDefinitionRegistrars());
}
````

由上面代码可以看出，Spring要处理四种类：

| 普通类                            | 扫描包的时候就完成了注册                                     |      |
| --------------------------------- | ------------------------------------------------------------ | ---- |
| `ImportSelecor`类                 | 先放进一个叫`configurationClasses`的map当中，再注册          |      |
| `ImportBeanDefinitionRegistrar`类 | 也先放进`configClass`这样一个map当中，在`loadBeanDefinitionsFromRegistrars`方法中注册 |      |
| Import普通的类                    | 也是先放入`configurationClasses`的map当中，再注册            |      |

也就是说`@Import`注解会把三种类注册进来，**Spring比较牛逼的地方在于它处理普通类的时候继续判断这个import的普通类是否有`@Import`注解**

处理完了`BeanDefinitionRegistryPostProcessor`类后，我们接着看Spring是怎么处理`BeanFactoryPostProcessor`，这个很重要。

继续阅读`PostProcessorRegistrationDelegate#invokeBeanFactoryPostProcessors`的方法，可见处理的方法是：`invokeBeanFactoryPostProcessors()`方法

跳转到`ConfigurationClassPostProcessor#postProcessBeanFactory`

```java
@Override
public void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) {
   int factoryId = System.identityHashCode(beanFactory);
   if (this.factoriesPostProcessed.contains(factoryId)) {
      throw new IllegalStateException(
            "postProcessBeanFactory already called on this post-processor against " + beanFactory);
   }
   this.factoriesPostProcessed.add(factoryId);
   if (!this.registriesPostProcessed.contains(factoryId)) {
      // BeanDefinitionRegistryPostProcessor hook apparently not supported...
      // Simply call processConfigurationClasses lazily at this point then.
      processConfigBeanDefinitions((BeanDefinitionRegistry) beanFactory);
   }

   enhanceConfigurationClasses(beanFactory);
   beanFactory.addBeanPostProcessor(new ImportAwareBeanPostProcessor(beanFactory));
}
```

继续到

```java
public void enhanceConfigurationClasses(ConfigurableListableBeanFactory beanFactory) {
   Map<String, AbstractBeanDefinition> configBeanDefs = new LinkedHashMap<>();
   for (String beanName : beanFactory.getBeanDefinitionNames()) {
      BeanDefinition beanDef = beanFactory.getBeanDefinition(beanName);
      // 判断类是否是全注解，简单来说就是是否加了`@Configuration`
      if (ConfigurationClassUtils.isFullConfigurationClass(beanDef)) {
         if (!(beanDef instanceof AbstractBeanDefinition)) {
            throw new BeanDefinitionStoreException("Cannot enhance @Configuration bean definition '" +
                  beanName + "' since it is not stored in an AbstractBeanDefinition subclass");
         }
         else if (logger.isWarnEnabled() && beanFactory.containsSingleton(beanName)) {
            logger.warn("Cannot enhance @Configuration bean definition '" + beanName +
                  "' since its singleton instance has been created too early. The typical cause " +
                  "is a non-static @Bean method with a BeanDefinitionRegistryPostProcessor " +
                  "return type: Consider declaring such methods as 'static'.");
         }
         configBeanDefs.put(beanName, (AbstractBeanDefinition) beanDef);
      }
   }
   if (configBeanDefs.isEmpty()) {
      // nothing to enhance -> return immediately
      return;
   }

   ConfigurationClassEnhancer enhancer = new ConfigurationClassEnhancer();
   for (Map.Entry<String, AbstractBeanDefinition> entry : configBeanDefs.entrySet()) {
      AbstractBeanDefinition beanDef = entry.getValue();
      // If a @Configuration class gets proxied, always proxy the target class
      beanDef.setAttribute(AutoProxyUtils.PRESERVE_TARGET_CLASS_ATTRIBUTE, Boolean.TRUE);
      try {
         // Set enhanced subclass of the user-specified bean class
         Class<?> configClass = beanDef.resolveBeanClass(this.beanClassLoader);
         if (configClass != null) {
            // 完成对注解类的cglb代理
            Class<?> enhancedClass = enhancer.enhance(configClass, this.beanClassLoader);
            if (configClass != enhancedClass) {
               if (logger.isDebugEnabled()) {
                  logger.debug(String.format("Replacing bean definition '%s' existing class '%s' with " +
                        "enhanced class '%s'", entry.getKey(), configClass.getName(), enhancedClass.getName()));
               }
               beanDef.setBeanClass(enhancedClass);
            }
         }
      }
      catch (Throwable ex) {
         throw new IllegalStateException("Cannot load configuration class: " + beanDef.getBeanClassName(), ex);
      }
   }
}
```

在上面方法判断注解类是否是全注解，如果是就对其加上cglib代理，这儿很重要。我们继续看是怎么代理的

```java
public Class<?> enhance(Class<?> configClass, @Nullable ClassLoader classLoader) {
  // 判断是否已经代理了？因为代理会为其增加父类 EnhancedConfiguration 如果类型一致就说明已经加了，所以被代理了
  if (EnhancedConfiguration.class.isAssignableFrom(configClass)) {
      if (logger.isDebugEnabled()) {
         logger.debug(String.format("Ignoring request to enhance %s as it has " +
               "already been enhanced. This usually indicates that more than one " +
               "ConfigurationClassPostProcessor has been registered (e.g. via " +
               "<context:annotation-config>). This is harmless, but you may " +
               "want check your configuration and remove one CCPP if possible",
               configClass.getName()));
      }
      return configClass;
   }
   // cglib 
   Class<?> enhancedClass = createClass(newEnhancer(configClass, classLoader));
   if (logger.isDebugEnabled()) {
      logger.debug(String.format("Successfully enhanced %s; enhanced class name is: %s",
            configClass.getName(), enhancedClass.getName()));
   }
   return enhancedClass;
}
```

所以有：`AppConfig` -> `cglib代理` -> `bd` -> `bdMap`

```java
private Enhancer newEnhancer(Class<?> configSuperClass, @Nullable ClassLoader classLoader) {
  Enhancer enhancer = new Enhancer();
  // 增强父类，因为cglib是基于继承
  enhancer.setSuperclass(configSuperClass);
  // 增强接口，为什么要增强接口，这是因为便于判断这个类是否被增强了
  // EnhancedConfiguration为了让我们用CGLIB代理的时候获得beanFactory
  enhancer.setInterfaces(new Class<?>[] {EnhancedConfiguration.class});
  enhancer.setUseFactory(false);
  enhancer.setNamingPolicy(SpringNamingPolicy.INSTANCE);
  // BeanFactoryAwareGeneratorStrategy是一个生成策略
  // 主要为生成的CGLIB类中添加成员变量$$beanFactory
  // 同时基于接口EnhancedConfiguration的父接口BeanFactoryAware中的setBeanFactory方法
  // 设置此变量的值为当前context的beanFactory，如果依赖我们这个cglib代理的对象就有了beanFactory
  // 有了factory就能获得对象，而不用去通过方法获得对象，因为通过方法获得对象不能控制器过滤
  // 该BeanFactory的作用是在this调用时拦截该调用，并直接在beanFactory中获得目标bean
  enhancer.setStrategy(new BeanFactoryAwareGeneratorStrategy(classLoader));
  // 为代理方法添加过滤器，
  // 主要是在方法调用前判断一些逻辑
  enhancer.setCallbackFilter(CALLBACK_FILTER);
  enhancer.setCallbackTypes(CALLBACK_FILTER.getCallbackTypes());
  return enhancer;
}
```

1. `EnhancedConfiguration.class`

   ````java
   public interface EnhancedConfiguration extends BeanFactoryAware {
   }
   ````

   ```java
   public interface BeanFactoryAware extends Aware {
   
      void setBeanFactory(BeanFactory beanFactory) throws BeansException;
   
   }
   ```

   **`EnhancedConfiguration`类可以让我们拿到`beanFactory`**，为什么这么设计用CGLIB代理？因为在我们的配置里面可以去new一个bean：

   ````java
   @Configuration
   @ComponentScan(basePackages = "com.spring")
   public class AppConfig {
   
   	@Bean
   	public A a() {
   		return new A();
   	}
   
   	@Bean
   	public B b() {
   		a();
   		return new B();
   	}
   
   }
   ````

   如果我们不使用代理，每次都去new一个新的对象，**违背了我们单例的原则**，还有就是为了避免相互调用，如上面的`b()`方法，如果创建2个A对象，整个Spring都乱套了，所以生成代理的时候也对方法进行了代理，这样如果该对象已经创建，那么就去`BeanFactory`中去拿该对象， 而不是new。而`BeanFactoryAware`接口，是在最开始的时候就注入进Spring，具体参考初始化6个类的地方。

   下面看一个简单的cglib的例子：

   1. 被代理对象

      ```java
      public class TestTraget {
      
      	public void test() {
      		System.out.println("方法逻辑");
      	}
      }
      ```

   2. 方法拦截器

      ```java
      public class TestMethodInterceptor implements MethodInterceptor {
      
         // methodProxy 方法的代理 通过这个执行父类的方法，但是传入子类的对象
         @Override
         public Object intercept(Object o, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable {
            System.out.println("代理");
            return methodProxy.invokeSuper(o, objects);
         }
      }
      ```

   3. 测试

      ```java
      public class Test {
      
         public static void main(String[] args) {
            Enhancer enhancer = new Enhancer();
            enhancer.setSuperclass(TestTraget.class);
            enhancer.setCallback(new TestMethodInterceptor());
            TestTraget o = (TestTraget) enhancer.create();
            o.test();
         }
      }
      ```

2. `CALLBACK_FILTER`

```java
private static final Callback[] CALLBACKS = new Callback[] {
      // 增强方法
  		// 不每一次都去调用new
      new BeanMethodInterceptor(),
  		// 设置一个beanFactory
      new BeanFactoryAwareMethodInterceptor(),
      NoOp.INSTANCE
};
```

`BeanMethodInterceptor#intercept`

```java
@Override
@Nullable
public Object intercept(Object enhancedConfigInstance, Method beanMethod, Object[] beanMethodArgs,
         MethodProxy cglibMethodProxy) throws Throwable {
   // enhancedConfigInstance 是代理对象，拿到$$beanFactory
   ConfigurableBeanFactory beanFactory = getBeanFactory(enhancedConfigInstance);
   // 方法名作为bean名字
   String beanName = BeanAnnotationHelper.determineBeanNameFor(beanMethod);

   // Determine whether this bean is a scoped-proxy
   Scope scope = AnnotatedElementUtils.findMergedAnnotation(beanMethod, Scope.class);
   if (scope != null && scope.proxyMode() != ScopedProxyMode.NO) {
      String scopedBeanName = ScopedProxyCreator.getTargetBeanName(beanName);
      if (beanFactory.isCurrentlyInCreation(scopedBeanName)) {
         beanName = scopedBeanName;
      }
   }

   // 1.判断方法返回的对象是不是factoryBean 从beanFactory中拿一个&+beanName，如果能拿到，说明是factoryBean
   // 2.如果是就创建本身的代理对象，然后对其getObject()里面的返回的对象创建一个代理
   if (factoryContainsBean(beanFactory, BeanFactory.FACTORY_BEAN_PREFIX + beanName) &&
         factoryContainsBean(beanFactory, beanName)) {
      Object factoryBean = beanFactory.getBean(BeanFactory.FACTORY_BEAN_PREFIX + beanName);
      if (factoryBean instanceof ScopedProxyFactoryBean) {
         // Scoped proxy factory beans are a special case and should not be further proxied
      }
      else {
         // It is a candidate FactoryBean - go ahead with enhancement
         return enhanceFactoryBean(factoryBean, beanMethod.getReturnType(), beanFactory, beanName);
      }
   }
		
   if (isCurrentlyInvokedFactoryMethod(beanMethod)) {
      // The factory is calling the bean method in order to instantiate and register the bean
      // (i.e. via a getBean() call) -> invoke the super implementation of the method to actually
      // create the bean instance.
      if (logger.isWarnEnabled() &&
            BeanFactoryPostProcessor.class.isAssignableFrom(beanMethod.getReturnType())) {
         logger.warn(String.format("@Bean method %s.%s is non-static and returns an object " +
                     "assignable to Spring's BeanFactoryPostProcessor interface. This will " +
                     "result in a failure to process annotations such as @Autowired, " +
                     "@Resource and @PostConstruct within the method's declaring " +
                     "@Configuration class. Add the 'static' modifier to this method to avoid " +
                     "these container lifecycle issues; see @Bean javadoc for complete details.",
               beanMethod.getDeclaringClass().getSimpleName(), beanMethod.getName()));
      }
      return cglibMethodProxy.invokeSuper(enhancedConfigInstance, beanMethodArgs);
   }
   // 创建代理的时候对方法进行代理
   return resolveBeanReference(beanMethod, beanMethodArgs, beanFactory, beanName);
}
```

1. 先判断是否是`FactoryBean`（从beanFactory中拿`&` + beanName是否存在？），如果是就为其实现类创建代理，然后对getObject()方法返回的对象创建代理

2. `isCurrentlyInvokedFactoryMethod(beanMethod)`判断执行的方法和调用的方法是不是同一个方法，因为我们要判断这个`@Bean`注解标注的方法到底是去new还是去beanFactory中get

   ````java
   // b()是被调用的方法，a(),是正在执行的方法
   public B b() {
     a();
     return new B();
   }
   ````

   Spring在这点上很聪明。为什么能这么操作，因为cglib有这样的支持

   ````java
   public class TestMethodInterceptor implements MethodInterceptor {
   
      // methodProxy 方法的代理 对应上面方法中的b()
      // method 是正在执行的方法 对应上面的a()
      @Override
      public Object intercept(Object o, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable {
         System.out.println("代理");
         return methodProxy.invokeSuper(o, objects);
      }
   }
   ````

   而源码也基本是这样：

   ````java
   private boolean isCurrentlyInvokedFactoryMethod(Method method) {
   			Method currentlyInvoked = SimpleInstantiationStrategy.getCurrentlyInvokedFactoryMethod();
   			return (currentlyInvoked != null && method.getName().equals(currentlyInvoked.getName()) &&
   					Arrays.equals(method.getParameterTypes(), currentlyInvoked.getParameterTypes()));
   		}
   ````

3. 所以如果代理方法和执行方法一致，说明要去new这个对象，对应`return cglibMethodProxy.invokeSuper(enhancedConfigInstance, beanMethodArgs);`

4. 如果不一致就会去从`beanFactory`中get，对应`resolveBeanReference`这个方法。

`BeanFactoryAwareMethodInterceptor#intercept`

```java
@Override
@Nullable
public Object intercept(Object obj, Method method, Object[] args, MethodProxy proxy) throws Throwable {
   Field field = ReflectionUtils.findField(obj.getClass(), BEAN_FACTORY_FIELD);
   Assert.state(field != null, "Unable to find generated BeanFactory field");
   field.set(obj, args[0]);

   // Does the actual (non-CGLIB) superclass implement BeanFactoryAware?
   // If so, call its setBeanFactory() method. If not, just exit.
   if (BeanFactoryAware.class.isAssignableFrom(ClassUtils.getUserClass(obj.getClass().getSuperclass()))) {
      return proxy.invokeSuper(obj, args);
   }
   return null;
}
```

所以代理类里面的过滤器的作用就是防止new，因为会去判断这个类是否被创建，还有去处理factoryBean的逻辑。

如果在`AppConfig`类里面处理static的bean方法的时候没有办法过滤，在处理`@Import`的地方就已经处理了，不会在后面处理`@Configuration`的时候处理了。

 这里说一个小的知识点，通过下面的的命令，可以拿到cglib生成的代理类的class文件

```
java -classpath "D:\xxxxxx\jdkxxx\lib\sa-jdi.java" sun.jvm.hotspot.HSDB
```

选择正在运行的CGLIB进程就可以在执行的目录拿到cglib代理出来的类的class，放入idea中就可以反编译了。**cglib是通过操作字节码来生成代理的。**

至此已经看了很多的代码，但其实只是`refresh()`里面的一个小方法而已，接下来我们暂时总结一波。

## 总结

1. `BeanPostProcessor`

   插手bean的实例化过程，是在bean实例化之后，在bean没有被spring的bean容器管理之前。

   经典场景：`@PostConstrut`、aop、bean的生命周期回调，主要在`CommonPostProcessors`类里面

2. `BeanFactoryPostProcessor`

   spring bean容器当中任意一个bean被new出来之前执行，针对beanFactory来建设

   经典场景：ConfigurationClassPostProcessor#postProcessBeanFactory，主要是针对配置类加上cglib代理

3. `BeanDefinitionRegistryPostProcessor`

   是`BeanFactoryPostProcessor`的子类，在`BeanFactoryPostProcessor`的子类，主要处理扫描`@CompoentScan`中配置的package中的class文件，还有3中`@Import`的扫描，@Bean的扫描，判断配置类是否是一个完整的配置类

4. `ImportSelector`

   通过这个方法selectImport返回一个类名（全名），把它变成bd，动态添加bd（这个bd是死的）

5. `ImportBeanDefinitionRegistar`

   registerBeanDefinition方法可以得到BeanDefinitoinRegistar故而可以动态添加bd，可以改变bd，经典应用场景就是mybatis的mapperScan