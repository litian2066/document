# Spring源码分析

## 1、Spring启动

那么就从头分析起，首先我们来看`Spring`启动的方式，这儿采用的是`Java Config`方式

```java
public static void main(String[] args) {
		AnnotationConfigApplicationContext context
				= new AnnotationConfigApplicationContext();
		context.register(AppConfig.class);
		context.refresh();
		IndexDao indexDao = context.getBean(IndexDao.class);
		indexDao.saySomething();
	}
```

首先我们来看下面这段代码

```java
AnnotationConfigApplicationContext context
				= new AnnotationConfigApplicationContext();
```

### 1、分析构造方法

```java
/**
	 * 初始化Bean的定义的阅读器
	 * 初始化Bean的定义的扫描器
	 * Create a new AnnotationConfigApplicationContext that needs to be populated
	 * through {@link #register} calls and then manually {@linkplain #refresh refreshed}.
*/
public AnnotationConfigApplicationContext() {
    this.reader = new AnnotatedBeanDefinitionReader(this);
    this.scanner = new ClassPathBeanDefinitionScanner(this);
}
```

**这儿初始化的`Scanner`，并不是Spring自己要用的，而是让我们用的，它会自己在对应的方法里面new一个局部变量。**

1. 可以得知首先执行父类的构造方法

   ```java
   public class AnnotationConfigApplicationContext extends GenericApplicationContext implements AnnotationConfigRegistry {
   }    
   ```

   ` GenericApplicationContext` 的构造方法

   ```java
   public GenericApplicationContext() {
       this.beanFactory = new DefaultListableBeanFactory();
   }
   ```

   可见，会实例化一个工厂类，`DefaultListableBeanFactory` 是一个Spring环境的工厂，在整个`ApplicationContext`环境下

   我们简单看看`DefaultListableBeanFactory` 

   ```java
   /**
   	用做排序
   **/
   @Nullable
   private Comparator<Object> dependencyComparator;
   
   /** Map of bean definition objects, keyed by bean name */
   /**
   	这个beanDefinitionMap很重要， 它存放了beanDefinition的map
   **/
   private final Map<String, BeanDefinition> beanDefinitionMap = new ConcurrentHashMap<>(256);
   
   /** 存放BeanName的list */
   private volatile List<String> beanDefinitionNames = new ArrayList<>(256);
   ```

   **注意**：`beanDefinitionMap`维护一个map，它的key是`beanName`, value是`beanDefinition`，**很重要**

   ````
   beanDefinition是Spring对于Bean的描述，包括一些个属性， 比如scope，BeanName，BeanClassName，dendsOn，是否懒加载以及等等，就像Java描述Class文件一样有一个Class的对象，有Method，Field，Constructor之类的属性。如下
   ````

   ```java
   
   public interface BeanDefinition extends AttributeAccessor, BeanMetadataElement {
   
       String SCOPE_SINGLETON = ConfigurableBeanFactory.SCOPE_SINGLETON;
   
       String SCOPE_PROTOTYPE = ConfigurableBeanFactory.SCOPE_PROTOTYPE;
   
       int ROLE_APPLICATION = 0;
   
       int ROLE_SUPPORT = 1;
   
       int ROLE_INFRASTRUCTURE = 2;
   
       void setParentName(@Nullable String parentName);
   
       @Nullable
       String getParentName();
   
       void setBeanClassName(@Nullable String beanClassName);
   
       @Nullable
       String getBeanClassName();
   
       void setScope(@Nullable String scope);
   
       @Nullable
       String getScope();
   
       void setLazyInit(boolean lazyInit);
   
       boolean isLazyInit();
   
       void setDependsOn(@Nullable String... dependsOn);
   
       @Nullable
       String[] getDependsOn();
   
       void setAutowireCandidate(boolean autowireCandidate);
   
       boolean isAutowireCandidate();
       
       void setPrimary(boolean primary);
   
       boolean isPrimary();
   
       void setFactoryBeanName(@Nullable String factoryBeanName);
   
       @Nullable
       String getFactoryBeanName();
   
       void setFactoryMethodName(@Nullable String factoryMethodName);
   
       @Nullable
       String getFactoryMethodName();
   
       ConstructorArgumentValues getConstructorArgumentValues();
   
       default boolean hasConstructorArgumentValues() {
           return !getConstructorArgumentValues().isEmpty();
       }
   
       MutablePropertyValues getPropertyValues();
   
       default boolean hasPropertyValues() {
           return !getPropertyValues().isEmpty();
       }
   
       boolean isSingleton();
   
       boolean isPrototype();
   
       boolean isAbstract();
   
       int getRole();
   
       @Nullable
       String getDescription();
   
       @Nullable
       String getResourceDescription();
   
       @Nullable
       BeanDefinition getOriginatingBeanDefinition();
   
   }
   ```

   ```
   beanDefinitionNames维护一个beanname的list，有几个beanDefinition就有几个beanName
   ```

2. 我们接着往下看，我们看`AnnotationConfigApplicationContext`默认的构造方法

   ```java
   public AnnotationConfigApplicationContext() {
       this.reader = new AnnotatedBeanDefinitionReader(this);
       this.scanner = new ClassPathBeanDefinitionScanner(this);
   }
   ```

   ```java
   // 顾名思义，reader是一个BeanDefinition的读取器
   private final AnnotatedBeanDefinitionReader reader;
   
   private final ClassPathBeanDefinitionScanner scanner;
   ```

   `AnnotatedBeanDefinitionReader`就是一个读取器, 它的作用就是把我们标注`@Compoent`元注解的类转化为一个`BeanDefinition`的类，目前这个类是Annotation开头的说明是只能读取加了注解的类，如果是xml的方式肯定有其他的Reader类来读取

   我们进一步来看`this.reader = new AnnotatedBeanDefinitionReader(this);`

   可以看出，这个方法将this传进去，`this代表AnnotationConfigApplicationContext, 也就是整个Spring的环境` 我们看下是怎么构造的？

   ```java
   public AnnotatedBeanDefinitionReader(BeanDefinitionRegistry registry) {
       this(registry, getOrCreateEnvironment(registry));
   }
   ```

   ````
   AnnotatedBeanDefinitionReader类通过一个BeanDefinitionRegistry的类来接受AnnotationConfigApplicationContext，说明BeanDefinitionRegistry和AnnotationConfigApplicationContext是一样的,他们之间是相等的，同时也是Spring的环境
   ````

   `BeanDefinitionRegistry`顾名思义就是一个`BeanDefinition`的注册器。所以将`bean`加入到`beanDefinitionMap`的过程如下：

   `@Compoent标注的类`-> `AnnotatedBeanDefinitionReader`-> 读取`(register(xxx))`->`new BeanDefinition()`->转换成`beanBeanDefinition`->通过`BeanDefinitionRegistry`-> 注册 (`registry.registerBeanDefinition(beanName, definition);`)-> `beanDefinitionMap`

   接着看`this(registry, getOrCreateEnvironment(registry));`代码

   ```java
   public AnnotatedBeanDefinitionReader(BeanDefinitionRegistry registry, Environment environment) {
       Assert.notNull(registry, "BeanDefinitionRegistry must not be null");
       Assert.notNull(environment, "Environment must not be null");
       this.registry = registry;
       this.conditionEvaluator = new ConditionEvaluator(registry, environment, null);
       AnnotationConfigUtils.registerAnnotationConfigProcessors(this.registry); // 进入此方法
   }
   ```

   进一步看`AnnotationConfigUtils.registerAnnotationConfigProcessors(this.registry);`

   ```java
   public static Set<BeanDefinitionHolder> registerAnnotationConfigProcessors(
   			BeanDefinitionRegistry registry, @Nullable Object source) {
   
       DefaultListableBeanFactory beanFactory = unwrapDefaultListableBeanFactory(registry);
       if (beanFactory != null) {
           if (!(beanFactory.getDependencyComparator() instanceof AnnotationAwareOrderComparator)) {
   				 // 添加AnnotationAwareOrderComparator类的对象 主要解析@order注解和@Priority，处理排序
            beanFactory.setDependencyComparator(AnnotationAwareOrderComparator.INSTANCE);
           }
           if (!(beanFactory.getAutowireCandidateResolver() instanceof ContextAnnotationAutowireCandidateResolver)) {
               // ContextAnnotationAutowireCandidateResolver提供处理延迟加载的功能       
               beanFactory.setAutowireCandidateResolver(new ContextAnnotationAutowireCandidateResolver());
           }
       }
   	// BeanDefinitionHolder 没有什么作用，就是一个map 里面有一个name和beandifition，只是封装了一下方便传参。
       Set<BeanDefinitionHolder> beanDefs = new LinkedHashSet<>(8);
   	// BeanDefinition的注册， 这里很重要，需要注册每个bean的类型
       // 判断整个环境是否包含了这个CONFIGURATION_ANNOTATION_PROCESSOR_BEAN_NAME
       if (!registry.containsBeanDefinition(CONFIGURATION_ANNOTATION_PROCESSOR_BEAN_NAME)) {
           // 这儿因为registry明显没有这个常量，所以取反,这儿一定能进来
           // 这个RootBeanDefinition 是Beandefinition的一种实现, 是spring内部提供的类
           /***
           	往beanDefinitionMap注册一个ConfigurationClassPostProcessor
           	why？
           	因为需要在后面的invokeBeanFactoryPostProcessors()方法用到，下面有写
           	这个方法主要是在spring的beanFactory初始化的过程中去做一些事情，怎么来做这些事情？
           	委托了多个实现了BeanDefinitionRegistryPostProcessor或者BeanFcatoryProcessor接口的类来做这些事情，有自定的也有spring内部的，其中ConfigurationClassPostProcessor就是一个spring内部的BeanDefinitionRegistryPostProcessor，因为如果你不添加这里就没有办法委托ConfigurationClassPostProcessor做一些功能
           ***/
           RootBeanDefinition def = new RootBeanDefinition(ConfigurationClassPostProcessor.class);
           def.setSource(source);
           // 注册进入map的核心方法
           beanDefs.add(registerPostProcessor(registry, def, CONFIGURATION_ANNOTATION_PROCESSOR_BEAN_NAME));
       }
   	
       if (!registry.containsBeanDefinition(AUTOWIRED_ANNOTATION_PROCESSOR_BEAN_NAME)) {
           RootBeanDefinition def = new RootBeanDefinition(AutowiredAnnotationBeanPostProcessor.class);
           def.setSource(source);
           beanDefs.add(registerPostProcessor(registry, def, AUTOWIRED_ANNOTATION_PROCESSOR_BEAN_NAME));
       }
   
       if (!registry.containsBeanDefinition(REQUIRED_ANNOTATION_PROCESSOR_BEAN_NAME)) {
           RootBeanDefinition def = new RootBeanDefinition(RequiredAnnotationBeanPostProcessor.class);
           def.setSource(source);
           beanDefs.add(registerPostProcessor(registry, def, REQUIRED_ANNOTATION_PROCESSOR_BEAN_NAME));
       }
   
       // Check for JSR-250 support, and if present add the CommonAnnotationBeanPostProcessor.
       if (jsr250Present && !registry.containsBeanDefinition(COMMON_ANNOTATION_PROCESSOR_BEAN_NAME)) {
           RootBeanDefinition def = new RootBeanDefinition(CommonAnnotationBeanPostProcessor.class);
           def.setSource(source);
           beanDefs.add(registerPostProcessor(registry, def, COMMON_ANNOTATION_PROCESSOR_BEAN_NAME));
       }
   
       // Check for JPA support, and if present add the PersistenceAnnotationBeanPostProcessor.
       if (jpaPresent && !registry.containsBeanDefinition(PERSISTENCE_ANNOTATION_PROCESSOR_BEAN_NAME)) {
           RootBeanDefinition def = new RootBeanDefinition();
           try {
               def.setBeanClass(ClassUtils.forName(PERSISTENCE_ANNOTATION_PROCESSOR_CLASS_NAME,
                                                   AnnotationConfigUtils.class.getClassLoader()));
           }
           catch (ClassNotFoundException ex) {
               throw new IllegalStateException(
                   "Cannot load optional framework class: " + PERSISTENCE_ANNOTATION_PROCESSOR_CLASS_NAME, ex);
           }
           def.setSource(source);
           beanDefs.add(registerPostProcessor(registry, def, PERSISTENCE_ANNOTATION_PROCESSOR_BEAN_NAME));
       }
   
       if (!registry.containsBeanDefinition(EVENT_LISTENER_PROCESSOR_BEAN_NAME)) {
           RootBeanDefinition def = new RootBeanDefinition(EventListenerMethodProcessor.class);
           def.setSource(source);
           beanDefs.add(registerPostProcessor(registry, def, EVENT_LISTENER_PROCESSOR_BEAN_NAME));
       }
   
       if (!registry.containsBeanDefinition(EVENT_LISTENER_FACTORY_BEAN_NAME)) {
           RootBeanDefinition def = new RootBeanDefinition(DefaultEventListenerFactory.class);
           def.setSource(source);
           beanDefs.add(registerPostProcessor(registry, def, EVENT_LISTENER_FACTORY_BEAN_NAME));
       }
   
       return beanDefs;
   }
   ```

   在这个方法里面将6个类注册进入了Spring的环境里面`beanDefinitionMap`里面

   详细分析:

   ````java
   RootBeanDefinition def = new RootBeanDefinition(ConfigurationClassPostProcessor.class);
           def.setSource(source);
           beanDefs.add(registerPostProcessor(registry, def, CONFIGURATION_ANNOTATION_PROCESSOR_BEAN_NAME));
   ````

   ```java
   /*
   由上可以总结:通过AnnotatedBeanDefinitionReader读取bean来生成beanDefinition,其实是通过直接new的方式,比如RootBeanDefinition def = new RootBeanDefinition(ConfigurationClassPostProcessor.class); 这段代码,然后通过registerPostProcessor的方法注册进入beanDefinitionMap里面,可以查看里面的方法如下
   */
   private static BeanDefinitionHolder registerPostProcessor(
   			BeanDefinitionRegistry registry, RootBeanDefinition definition, String beanName) {
   
   		definition.setRole(BeanDefinition.ROLE_INFRASTRUCTURE);
       	// 这是核心代码,registry就是通过此方法将beanDefinition注册进入beanDMap里面
   		registry.registerBeanDefinition(beanName, definition);
   		return new BeanDefinitionHolder(definition, beanName);
   	}
   ```

   综上 `registerAnnotationConfigProcessors` 这个方法主要是往`beanDefinitionMap`里面注册几个对，

   **其中最重要的是`ConfigurationClassPostProcessor`，重要到能打破你的三观。下面会分析。**

3. `this.scanner = new ClassPathBeanDefinitionScanner(this);`

   实例化`ClassPathBeanDefinitionScanner`, 能够扫描一个类/包转换为我们的`beanDefinition`

   等分析bean的实例化的时候我们再来看它的底层代码实现，这个类给我们程序员用的。

### 2、分析注册方法

咱们再来看`context.register(AppConfig.class);`这个方法

```java
public void register(Class<?>... annotatedClasses) {
    Assert.notEmpty(annotatedClasses, "At least one annotated class must be specified");
    this.reader.register(annotatedClasses);
}
```

```java
public void register(Class<?>... annotatedClasses) {
    for (Class<?> annotatedClass : annotatedClasses) {
        registerBean(annotatedClass);
    }
}
```

```java
public void registerBean(Class<?> annotatedClass) {
    doRegisterBean(annotatedClass, null, null, null);
}
```

```java
<T> void doRegisterBean(Class<T> annotatedClass, @Nullable Supplier<T> instanceSupplier, @Nullable String name,
			@Nullable Class<? extends Annotation>[] qualifiers, BeanDefinitionCustomizer... definitionCustomizers) {
		// 可见,是通过new的方式创建一个beandefinition
    AnnotatedGenericBeanDefinition abd = new AnnotatedGenericBeanDefinition(annotatedClass);
    if (this.conditionEvaluator.shouldSkip(abd.getMetadata())) {
        return;
    }

    abd.setInstanceSupplier(instanceSupplier);
    ScopeMetadata scopeMetadata = this.scopeMetadataResolver.resolveScopeMetadata(abd);
    abd.setScope(scopeMetadata.getScopeName());
    String beanName = (name != null ? name : this.beanNameGenerator.generateBeanName(abd, this.registry));

    AnnotationConfigUtils.processCommonDefinitionAnnotations(abd);
    if (qualifiers != null) {
        for (Class<? extends Annotation> qualifier : qualifiers) {
            if (Primary.class == qualifier) {
                abd.setPrimary(true);
            }
            else if (Lazy.class == qualifier) {
                abd.setLazyInit(true);
            }
            else {
                abd.addQualifier(new AutowireCandidateQualifier(qualifier));
            }
        }
    }
    for (BeanDefinitionCustomizer customizer : definitionCustomizers) {
        customizer.customize(abd);
    }

    BeanDefinitionHolder definitionHolder = new BeanDefinitionHolder(abd, beanName);
    definitionHolder = AnnotationConfigUtils.applyScopedProxyMode(scopeMetadata, definitionHolder, this.registry);
    // 通过这个方法注册到beanDefinitionMap里面
    BeanDefinitionReaderUtils.registerBeanDefinition(definitionHolder, this.registry);
}
```

```JAVA
public static void registerBeanDefinition(
			BeanDefinitionHolder definitionHolder, BeanDefinitionRegistry registry)
			throws BeanDefinitionStoreException {

    // Register bean definition under primary name.
    String beanName = definitionHolder.getBeanName();
    // 核心方法, 和上面的无二
    registry.registerBeanDefinition(beanName, definitionHolder.getBeanDefinition());

    // Register aliases for bean name, if any.
    String[] aliases = definitionHolder.getAliases();
    if (aliases != null) {
        for (String alias : aliases) {
            registry.registerAlias(beanName, alias);
        }
    }
}
```

由上可以看出``context.register(AppConfig.class);``这个方法,其实就是将类new成一个`beanDefinition`然后再通过`registry.registerBeanDefinition`的方法注册到`beanDefinitionMap`里面，其实`registry.registerBeanDefinition`就是一个map的put操作,不信？我们再往底层看。

定位到`GenericApplicationContext`

```java
@Override
public void registerBeanDefinition(String beanName, BeanDefinition beanDefinition)
    throws BeanDefinitionStoreException {
	// 此方法
    this.beanFactory.registerBeanDefinition(beanName, beanDefinition);
}
```

定位到`DefaultListableBeanFactory`#`registerBeanDefinition`

```java
this.beanDefinitionMap.put(beanName, beanDefinition);
```

由此可见，注册其实就是一个put操作。

至此我们已经将我们的配置类`AppConfig`注册进入了`beanDefinitionMap`里面了，与此同时还有上面的6个类也一并注册进入了`beanDefinitionMap`里面了。

### 3、分析`refresh()`

我们再来看`context.refresh();`这个方法主要是准备好bean工厂，实例化对象

```java
public void refresh() throws BeansException, IllegalStateException {
		synchronized (this.startupShutdownMonitor) {
            // 准备工作
            prepareRefresh();

            // 得到beanFactory因为需要对beanFactory进行设置
            ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();

            // 准备好bean工厂
            prepareBeanFactory(beanFactory);

            try {
                // 目前没有实现，留在以后的版本实现
                postProcessBeanFactory(beanFactory);

                // Invoke factory processors registered as beans in the context.
              	// 很重要
                // 在spring的环境中去执行已经被注册的factory processors
                // 设置执行自定义的ProcessBeanFactory
                invokeBeanFactoryPostProcessors(beanFactory);

                // Register bean processors that intercept bean creation.
                registerBeanPostProcessors(beanFactory);

                // Initialize message source for this context.
                initMessageSource();

                // Initialize event multicaster for this context.
                initApplicationEventMulticaster();

                // Initialize other special beans in specific context subclasses.
                onRefresh();

                // Check for listener beans and register them.
                registerListeners();

                // Instantiate all remaining (non-lazy-init) singletons.
                finishBeanFactoryInitialization(beanFactory);

                // Last step: publish corresponding event.
                finishRefresh();
            }

            catch (BeansException ex) {
                if (logger.isWarnEnabled()) {
                    logger.warn("Exception encountered during context initialization - " +
                                "cancelling refresh attempt: " + ex);
                }

                // Destroy already created singletons to avoid dangling resources.
                destroyBeans();

                // Reset 'active' flag.
                cancelRefresh(ex);

                // Propagate exception to caller.
                throw ex;
            }

            finally {
                // Reset common introspection caches in Spring's core, since we
                // might not ever need metadata for singleton beans anymore...
                resetCommonCaches();
            }
        }
}
```

1. `prepareRefresh();` 准备工作包括设置时间，是否激活标识位，初始化属性源配置

   `ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();` 得到beanFactory因为需要对beanFactory进行设置

2. `prepareBeanFactory(beanFactory)` 准备bean工厂

   ```java
   protected void prepareBeanFactory(ConfigurableListableBeanFactory beanFactory) {
   		// 1.添加一个类加载器
       beanFactory.setBeanClassLoader(getClassLoader());
       // 2.添加bean表达式解释器，为了能够让我们的beanFactory去解析bean表达式
       beanFactory.setBeanExpressionResolver(new StandardBeanExpressionResolver(beanFactory.getBeanClassLoader()));
       beanFactory.addPropertyEditorRegistrar(new ResourceEditorRegistrar(this, getEnvironment()));
   
       // 3.添加一个后置处理器， 这个处理器是为了能够在bean中得到各种*Aware（*Aware都有其作用）
       beanFactory.addBeanPostProcessor(new ApplicationContextAwareProcessor(this));
       // 4.添加了自动注入被忽略的列表
       beanFactory.ignoreDependencyInterface(EnvironmentAware.class);
       beanFactory.ignoreDependencyInterface(EmbeddedValueResolverAware.class);
       beanFactory.ignoreDependencyInterface(ResourceLoaderAware.class);
       beanFactory.ignoreDependencyInterface(ApplicationEventPublisherAware.class);
       beanFactory.ignoreDependencyInterface(MessageSourceAware.class);
       beanFactory.ignoreDependencyInterface(ApplicationContextAware.class);
   
       // BeanFactory interface not registered as resolvable type in a plain factory.
       // MessageSource registered (and found for autowiring) as a bean.
       beanFactory.registerResolvableDependency(BeanFactory.class, beanFactory);
       beanFactory.registerResolvableDependency(ResourceLoader.class, this);
       beanFactory.registerResolvableDependency(ApplicationEventPublisher.class, this);
       beanFactory.registerResolvableDependency(ApplicationContext.class, this);
   
       // 5.添加了一个ApplicationListenerDetector的后置处理器(百度)
       beanFactory.addBeanPostProcessor(new ApplicationListenerDetector(this));
   
       // Detect a LoadTimeWeaver and prepare for weaving, if found.
       if (beanFactory.containsBean(LOAD_TIME_WEAVER_BEAN_NAME)) {
           beanFactory.addBeanPostProcessor(new LoadTimeWeaverAwareProcessor(beanFactory));
           // Set a temporary ClassLoader for type matching.
           beanFactory.setTempClassLoader(new ContextTypeMatchClassLoader(beanFactory.getBeanClassLoader()));
       }
   
       // Register default environment beans.
       if (!beanFactory.containsLocalBean(ENVIRONMENT_BEAN_NAME)) {
           beanFactory.registerSingleton(ENVIRONMENT_BEAN_NAME, getEnvironment());
       }
       if (!beanFactory.containsLocalBean(SYSTEM_PROPERTIES_BEAN_NAME)) {
           beanFactory.registerSingleton(SYSTEM_PROPERTIES_BEAN_NAME, getEnvironment().getSystemProperties());
       }
       if (!beanFactory.containsLocalBean(SYSTEM_ENVIRONMENT_BEAN_NAME)) {
           beanFactory.registerSingleton(SYSTEM_ENVIRONMENT_BEAN_NAME, getEnvironment().getSystemEnvironment());
       }
   }
   ```
   

详细分析`beanFactory.addBeanPostProcessor(new ApplicationContextAwareProcessor(this));`这个方法

这个方法其实就是添加一个后置处理器，作用上面注释有写，但是前面是一个add操作，所以我们看下源码，这个方法在`AbstractBeanFactory`类里面。

```java
   @Override
   public void addBeanPostProcessor(BeanPostProcessor beanPostProcessor) {
       Assert.notNull(beanPostProcessor, "BeanPostProcessor must not be null");
       // 移除
       this.beanPostProcessors.remove(beanPostProcessor);
       // Track whether it is instantiation/destruction aware
       if (beanPostProcessor instanceof InstantiationAwareBeanPostProcessor) {
           this.hasInstantiationAwareBeanPostProcessors = true;
       }
       if (beanPostProcessor instanceof DestructionAwareBeanPostProcessor) {
           this.hasDestructionAwareBeanPostProcessors = true;
       }
       // Add to end of list
       this.beanPostProcessors.add(beanPostProcessor);
   }
```

```java
   private final List<BeanPostProcessor> beanPostProcessors = new CopyOnWriteArrayList<>();	
```

```
   可见，beanFactory里面维护了一个list，list里面存储的是各种后置处理器。但是到这一步还没有用到，在bean的实例化过程中会循环这个list依次来执行者list里面的后置处理器，达到插手bean的实例化过程的目的。
```



3. `invokeBeanFactoryPostProcessors(beanFactory);`

   ```java
   protected void invokeBeanFactoryPostProcessors(ConfigurableListableBeanFactory beanFactory) {
       // 这个地方需要注意getBeanFactoryPostProcessors()是获取自定义的后置处理器，下面的后置处理器里面有提到的怎么实现自己的后置处理器。
       // 
       PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors(beanFactory, getBeanFactoryPostProcessors());
   
       // Detect a LoadTimeWeaver and prepare for weaving, if found in the meantime
       // (e.g. through an @Bean method registered by ConfigurationClassPostProcessor)
       if (beanFactory.getTempClassLoader() == null && beanFactory.containsBean(LOAD_TIME_WEAVER_BEAN_NAME)) {
           beanFactory.addBeanPostProcessor(new LoadTimeWeaverAwareProcessor(beanFactory));
           beanFactory.setTempClassLoader(new ContextTypeMatchClassLoader(beanFactory.getBeanClassLoader()));
       }
   }
   ```

   `invokeBeanFactoryPostProcessors()`

   ````java
   public static void invokeBeanFactoryPostProcessors(
   			ConfigurableListableBeanFactory beanFactory, List<BeanFactoryPostProcessor> beanFactoryPostProcessors) {
   
       // Invoke BeanDefinitionRegistryPostProcessors first, if any.
       Set<String> processedBeans = new HashSet<>();
   
       if (beanFactory instanceof BeanDefinitionRegistry) {
           BeanDefinitionRegistry registry = (BeanDefinitionRegistry) beanFactory;
           // 我们自己定义的processors
           List<BeanFactoryPostProcessor> regularPostProcessors = new ArrayList<>();
           // spring内部定义的processors
           List<BeanDefinitionRegistryPostProcessor> registryProcessors = new ArrayList<>();
       	/****
                   因为我们自己定义的BeanFactoryProcessor可以有两种方式
                   1.实现BeanFactoryProcessor接口
                   2.实现BeanDefinitionRegistryPostProcessor
                   因为BeanDefinitionRegistryPostProcessor继承自BeanFactoryProcessor
                   于是可以猜想实现BeanFactoryProcessor和实现BeanDefinitionRegistryPostProcessor是可以实现不同的功能的，因为BeanDefinitionRegistryPostProcessor是子类，它肯定扩展了父类的功能
           *****/
           for (BeanFactoryPostProcessor postProcessor : beanFactoryPostProcessors) {
               if (postProcessor instanceof BeanDefinitionRegistryPostProcessor) {
                   BeanDefinitionRegistryPostProcessor registryProcessor =
                       (BeanDefinitionRegistryPostProcessor) postProcessor;
                   registryProcessor.postProcessBeanDefinitionRegistry(registry);
                   registryProcessors.add(registryProcessor);
               }
               else {
                   regularPostProcessors.add(postProcessor);
               }
           }
   
           // Do not initialize FactoryBeans here: We need to leave all regular beans
           // uninitialized to let the bean factory post-processors apply to them!
           // Separate between BeanDefinitionRegistryPostProcessors that implement
           // PriorityOrdered, Ordered, and the rest.
           /***
           这个currentRegistryProcessors放的是spring内部自己实现了BeanDefinitionRegistryPostProcessor接口的对象
         	***/
           List<BeanDefinitionRegistryPostProcessor> currentRegistryProcessors = new ArrayList<>();
   
           // First, invoke the BeanDefinitionRegistryPostProcessors that implement PriorityOrdered.
           // BeanDefinitionRegistryPostProcessor 等于 BeanFactoryPostProcessor
           /***
           	getBeanNamesForType是beanFactory内部的一个方法
           	通过类型得到bean的名字，这里的type指的是beanDefinition当中描述当前类的class类型
           ****/
           String[] postProcessorNames =
               beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, true, false);
         	// 循环保存一下BeanDefinitionRegistryPostProcessor后置处理器的名字到processedBeans
           for (String ppName : postProcessorNames) {
               if (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) {
                   currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));
                   processedBeans.add(ppName);
               }
           }
         	// 排序，不重要
           sortPostProcessors(currentRegistryProcessors, beanFactory);
           // 
           registryProcessors.addAll(currentRegistryProcessors);
         	// 执行Spring内部实现的一个BeanDefinitionRegistryPostProcessor，其实这里有一个ConfigClassProcessors
           invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry);
           currentRegistryProcessors.clear();
   
           // Next, invoke the BeanDefinitionRegistryPostProcessors that implement Ordered.
           postProcessorNames = beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, true, false);
           for (String ppName : postProcessorNames) {
               if (!processedBeans.contains(ppName) && beanFactory.isTypeMatch(ppName, Ordered.class)) {
                   currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));
                   processedBeans.add(ppName);
               }
           }
           sortPostProcessors(currentRegistryProcessors, beanFactory);
           registryProcessors.addAll(currentRegistryProcessors);
           invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry);
           currentRegistryProcessors.clear();
   
           // Finally, invoke all other BeanDefinitionRegistryPostProcessors until no further ones appear.
           boolean reiterate = true;
           while (reiterate) {
               reiterate = false;
               postProcessorNames = beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, true, false);
               for (String ppName : postProcessorNames) {
                   if (!processedBeans.contains(ppName)) {
                       currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));
                       processedBeans.add(ppName);
                       reiterate = true;
                   }
               }
               sortPostProcessors(currentRegistryProcessors, beanFactory);
               // 合并两个list
               registryProcessors.addAll(currentRegistryProcessors);
               /****
               	循环所有的实现了BeanDefinitionRegistryPostProcessor接口的类
               	调用扩展方法postProcessBeanDefinitionRegistry
               ****/
               invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry);
               currentRegistryProcessors.clear();
           }
   
           // Now, invoke the postProcessBeanFactory callback of all processors handled so far.
           invokeBeanFactoryPostProcessors(registryProcessors, beanFactory);
           invokeBeanFactoryPostProcessors(regularPostProcessors, beanFactory);
       }
   
       else {
           // Invoke factory processors registered with the context instance.
           invokeBeanFactoryPostProcessors(beanFactoryPostProcessors, beanFactory);
       }
   
       // Do not initialize FactoryBeans here: We need to leave all regular beans
       // uninitialized to let the bean factory post-processors apply to them!
       String[] postProcessorNames =
           beanFactory.getBeanNamesForType(BeanFactoryPostProcessor.class, true, false);
   
       // Separate between BeanFactoryPostProcessors that implement PriorityOrdered,
       // Ordered, and the rest.
       List<BeanFactoryPostProcessor> priorityOrderedPostProcessors = new ArrayList<>();
       List<String> orderedPostProcessorNames = new ArrayList<>();
       List<String> nonOrderedPostProcessorNames = new ArrayList<>();
       for (String ppName : postProcessorNames) {
           if (processedBeans.contains(ppName)) {
               // skip - already processed in first phase above
           }
           else if (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) {
               priorityOrderedPostProcessors.add(beanFactory.getBean(ppName, BeanFactoryPostProcessor.class));
           }
           else if (beanFactory.isTypeMatch(ppName, Ordered.class)) {
               orderedPostProcessorNames.add(ppName);
           }
           else {
               nonOrderedPostProcessorNames.add(ppName);
           }
       }
   
       // First, invoke the BeanFactoryPostProcessors that implement PriorityOrdered.
       sortPostProcessors(priorityOrderedPostProcessors, beanFactory);
       invokeBeanFactoryPostProcessors(priorityOrderedPostProcessors, beanFactory);
   
       // Next, invoke the BeanFactoryPostProcessors that implement Ordered.
       List<BeanFactoryPostProcessor> orderedPostProcessors = new ArrayList<>();
       for (String postProcessorName : orderedPostProcessorNames) {
           orderedPostProcessors.add(beanFactory.getBean(postProcessorName, BeanFactoryPostProcessor.class));
       }
       sortPostProcessors(orderedPostProcessors, beanFactory);
       invokeBeanFactoryPostProcessors(orderedPostProcessors, beanFactory);
   
       // Finally, invoke all other BeanFactoryPostProcessors.
       List<BeanFactoryPostProcessor> nonOrderedPostProcessors = new ArrayList<>();
       for (String postProcessorName : nonOrderedPostProcessorNames) {
           nonOrderedPostProcessors.add(beanFactory.getBean(postProcessorName, BeanFactoryPostProcessor.class));
       }
       invokeBeanFactoryPostProcessors(nonOrderedPostProcessors, beanFactory);
   
       // Clear cached merged bean definitions since the post-processors might have
       // modified the original metadata, e.g. replacing placeholders in values...
    beanFactory.clearMetadataCache();
   }
   ````
   
   ````java
   public interface BeanDefinitionRegistryPostProcessor extends BeanFactoryPostProcessor {
   
   	/**
   	 * Modify the application context's internal bean definition registry after its
   	 * standard initialization. All regular bean definitions will have been loaded,
   	 * but no beans will have been instantiated yet. This allows for adding further
   	 * bean definitions before the next post-processing phase kicks in.
   	 * @param registry the bean definition registry used by the application context
   	 * @throws org.springframework.beans.BeansException in case of errors
   	 */
   	void postProcessBeanDefinitionRegistry(BeanDefinitionRegistry registry) throws BeansException;

   }
   ````
   
````
   可见BeanDefinitionRegistryPostProcessor其实继承自BeanFactoryPostProcessor，可以猜想子类肯定比父类强大。
````

   里面的一个重要的方法`invokeBeanDefinitionRegistryPostProcessors()`

   ```java
   /***
   	循环所有的实现了BeanDefinitionRegistryPostProcessor接口的类，并调用它们的一个方法
   ***/
   private static void invokeBeanDefinitionRegistryPostProcessors(
       Collection<? extends BeanDefinitionRegistryPostProcessor> postProcessors, BeanDefinitionRegistry registry) {
   	/***
   		调用扩展方法postProcessBeanDefinitionRegistry
   	***/
       for (BeanDefinitionRegistryPostProcessor postProcessor : postProcessors) {
           postProcessor.postProcessBeanDefinitionRegistry(registry);
       }
}
   ```

   其实到这步就一个类进来，就是上面注释里面写的`ConfigurationClassPostProcessor`，所以我们继续看`ConfigurationClassPostProcessor#processConfigBeanDefinitions`，跳转到`processConfigBeanDefinitions`

   ```java
   public void processConfigBeanDefinitions(BeanDefinitionRegistry registry) {
   // 定义一个list，存放项目里面提供的bd
      List<BeanDefinitionHolder> configCandidates = new ArrayList<>();
      // 获取容器当中所有bd的名字
      String[] candidateNames = registry.getBeanDefinitionNames();
      // 这儿有7个，默认初始化6个，还有一个是我们的配置类
      for (String beanName : candidateNames) {
         BeanDefinition beanDef = registry.getBeanDefinition(beanName);
         // 如果配置类加了FULL 或者 LITE属性，意味着已经处理过了，
         if (ConfigurationClassUtils.isFullConfigurationClass(beanDef) ||
            ConfigurationClassUtils.isLiteConfigurationClass(beanDef)) {
            if (logger.isDebugEnabled()) {
               logger.debug("Bean definition has already been processed as a configuration class: " + beanDef);
            }
         }
         // 判断是否是@Configuration类，如果加了下面的这个注解就不用判断了：
         // @Compent、@ComponentScan、@Import、@ImportResource
      // 如果加了@Configuration就把属性定义一个FULL，没有就给LITE，如果加了@Compent、@ComponentScan、@Import、@ImportResource
         // 也会返回true，也就是加了这几个注解都会放进这个list里面进行接下来的处理
      // 就算不加@Configuration，只要加了其他几个。spring环境也是能用的。
         else if (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory)) {
            configCandidates.add(new BeanDefinitionHolder(beanDef, beanName));
         }
   }
   
      // Return immediately if no @Configuration classes were found
      if (configCandidates.isEmpty()) {
         return;
   }
   
      // Sort by previously determined @Order value, if applicable
      // 如果加了@Order注解就会去排序
      configCandidates.sort((bd1, bd2) -> {
      int i1 = ConfigurationClassUtils.getOrder(bd1.getBeanDefinition());
         int i2 = ConfigurationClassUtils.getOrder(bd2.getBeanDefinition());
         return Integer.compare(i1, i2);
      });
   
   // Detect any custom bean name generation strategy supplied through the enclosing application context
      SingletonBeanRegistry sbr = null;
      if (registry instanceof SingletonBeanRegistry) {
         sbr = (SingletonBeanRegistry) registry;
         if (!this.localBeanNameGeneratorSet) {
            BeanNameGenerator generator = (BeanNameGenerator) sbr.getSingleton(CONFIGURATION_BEAN_NAME_GENERATOR);
         if (generator != null) {
               this.componentScanBeanNameGenerator = generator;
               this.importBeanNameGenerator = generator;
            }
         }
      }
   
      if (this.environment == null) {
         this.environment = new StandardEnvironment();
      }
   
      // Parse each @Configuration class
      // 实例化ConfigurationClassParser 为了解析每一个@Configuration类
      ConfigurationClassParser parser = new ConfigurationClassParser(
            this.metadataReaderFactory, this.problemReporter, this.environment,
            this.resourceLoader, this.componentScanBeanNameGenerator, registry);
      // 实例化两个set，candidates用于将之前加入的configCandidates进行去重，因为可能有多个配置重复了，alreadyParsed用于判断已经处理过的
      Set<BeanDefinitionHolder> candidates = new LinkedHashSet<>(configCandidates);
      Set<ConfigurationClass> alreadyParsed = new HashSet<>(configCandidates.size());
      do {
         // 解析配置类，重要
         parser.parse(candidates);
         parser.validate();
   
         Set<ConfigurationClass> configClasses = new LinkedHashSet<>(parser.getConfigurationClasses());
         configClasses.removeAll(alreadyParsed);
   
         // Read the model and create bean definitions based on its content
         if (this.reader == null) {
            this.reader = new ConfigurationClassBeanDefinitionReader(
                  registry, this.sourceExtractor, this.resourceLoader, this.environment,
                  this.importBeanNameGenerator, parser.getImportRegistry());
         }
         this.reader.loadBeanDefinitions(configClasses);
         alreadyParsed.addAll(configClasses);
   
         candidates.clear();
         if (registry.getBeanDefinitionCount() > candidateNames.length) {
            String[] newCandidateNames = registry.getBeanDefinitionNames();
            Set<String> oldCandidateNames = new HashSet<>(Arrays.asList(candidateNames));
            Set<String> alreadyParsedClasses = new HashSet<>();
            for (ConfigurationClass configurationClass : alreadyParsed) {
               alreadyParsedClasses.add(configurationClass.getMetadata().getClassName());
            }
            for (String candidateName : newCandidateNames) {
               if (!oldCandidateNames.contains(candidateName)) {
                  BeanDefinition bd = registry.getBeanDefinition(candidateName);
                  if (ConfigurationClassUtils.checkConfigurationClassCandidate(bd, this.metadataReaderFactory) &&
                        !alreadyParsedClasses.contains(bd.getBeanClassName())) {
                     candidates.add(new BeanDefinitionHolder(bd, candidateName));
                  }
               }
            }
            candidateNames = newCandidateNames;
         }
      }
      while (!candidates.isEmpty());
   
      // Register the ImportRegistry as a bean in order to support ImportAware @Configuration classes
      if (sbr != null && !sbr.containsSingleton(IMPORT_REGISTRY_BEAN_NAME)) {
         sbr.registerSingleton(IMPORT_REGISTRY_BEAN_NAME, parser.getImportRegistry());
      }
   
      if (this.metadataReaderFactory instanceof CachingMetadataReaderFactory) {
         // Clear cache in externally provided MetadataReaderFactory; this is a no-op
         // for a shared cache since it'll be cleared by the ApplicationContext.
         ((CachingMetadataReaderFactory) this.metadataReaderFactory).clearCache();
      }
   }
   ```

   看上面注释就知道这个方法很重要，下面列举一下：

   1. 拿出所有的bdName，这儿有7个，6个spring默认注入，还有一个是我们的配置类
   2. 判断配置类是否加了`@Configuration`，如果加了就放进一个list里面，其实只要加了`@Compoent`元注解标注就会加进list里面让后面扫描，这儿有一个细节，如果加了`@Configuration`会在后面生成代理类。
   3. 解析配置类

   继续来看这个方法`parser.parse(candidates);`

   ```java
   public void parse(Set<BeanDefinitionHolder> configCandidates) {
      this.deferredImportSelectors = new LinkedList<>();
   
      for (BeanDefinitionHolder holder : configCandidates) {
         BeanDefinition bd = holder.getBeanDefinition();
         try {
            // 如果是加了注解的bd，就走这个方法
            if (bd instanceof AnnotatedBeanDefinition) {
               parse(((AnnotatedBeanDefinition) bd).getMetadata(), holder.getBeanName());
            }
            // 解析其他类型的bd
            else if (bd instanceof AbstractBeanDefinition && ((AbstractBeanDefinition) bd).hasBeanClass()) {
               parse(((AbstractBeanDefinition) bd).getBeanClass(), holder.getBeanName());
            }
            else {
               parse(bd.getBeanClassName(), holder.getBeanName());
            }
         }
         catch (BeanDefinitionStoreException ex) {
            throw ex;
         }
         catch (Throwable ex) {
            throw new BeanDefinitionStoreException(
                  "Failed to parse configuration class [" + bd.getBeanClassName() + "]", ex);
         }
      }
   
      processDeferredImportSelectors();
   }
   ```

   继续下一步

   ```java
   // 解析@Configuration的类
   	protected void processConfigurationClass(ConfigurationClass configClass) throws IOException {
   		if (this.conditionEvaluator.shouldSkip(configClass.getMetadata(), ConfigurationPhase.PARSE_CONFIGURATION)) {
   			return;
   		}
   
   		ConfigurationClass existingClass = this.configurationClasses.get(configClass);
   		if (existingClass != null) {
   			if (configClass.isImported()) {
   				if (existingClass.isImported()) {
   					existingClass.mergeImportedBy(configClass);
   				}
   				// Otherwise ignore new imported config class; existing non-imported class overrides it.
   				return;
   			}
   			else {
   				// Explicit bean definition found, probably replacing an import.
   				// Let's remove the old one and go with the new one.
   				this.configurationClasses.remove(configClass);
   				this.knownSuperclasses.values().removeIf(configClass::equals);
   			}
   		}
   
   		// Recursively process the configuration class and its superclass hierarchy.
   		// 封装成SourceClass
   		SourceClass sourceClass = asSourceClass(configClass);
   		do {
   			// 进入此方法
   			sourceClass = doProcessConfigurationClass(configClass, sourceClass);
   		}
   		while (sourceClass != null);
   
   		this.configurationClasses.put(configClass, configClass);
   	}
   ```

   `sourceClass = doProcessConfigurationClass(configClass, sourceClass);`

   ```java
   protected final SourceClass doProcessConfigurationClass(ConfigurationClass configClass, SourceClass sourceClass)
         throws IOException {
   
      // Recursively process any member (nested) classes first
      processMemberClasses(configClass, sourceClass);
   
      // Process any @PropertySource annotations
      for (AnnotationAttributes propertySource : AnnotationConfigUtils.attributesForRepeatable(
            sourceClass.getMetadata(), PropertySources.class,
            org.springframework.context.annotation.PropertySource.class)) {
         if (this.environment instanceof ConfigurableEnvironment) {
            processPropertySource(propertySource);
         }
         else {
            logger.warn("Ignoring @PropertySource annotation on [" + sourceClass.getMetadata().getClassName() +
                  "]. Reason: Environment must implement ConfigurableEnvironment");
         }
      }
   
      // 解析@ComponentScan注解
      Set<AnnotationAttributes> componentScans = AnnotationConfigUtils.attributesForRepeatable(
            sourceClass.getMetadata(), ComponentScans.class, ComponentScan.class);
      if (!componentScans.isEmpty() &&
            !this.conditionEvaluator.shouldSkip(sourceClass.getMetadata(), ConfigurationPhase.REGISTER_BEAN)) {
         // @ComponentScan里面的package不止一个
         for (AnnotationAttributes componentScan : componentScans) {
            // The config class is annotated with @ComponentScan -> perform the scan immediately
           // 使用ASM技术扫描类 生成bd
            Set<BeanDefinitionHolder> scannedBeanDefinitions =
                  this.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName());
            // Check the set of scanned definitions for any further config classes and parse recursively if needed
            for (BeanDefinitionHolder holder : scannedBeanDefinitions) {
               BeanDefinition bdCand = holder.getBeanDefinition().getOriginatingBeanDefinition();
               if (bdCand == null) {
                  bdCand = holder.getBeanDefinition();
               }
               if (ConfigurationClassUtils.checkConfigurationClassCandidate(bdCand, this.metadataReaderFactory)) {
                  parse(bdCand.getBeanClassName(), holder.getBeanName());
               }
            }
         }
      }
   
      // Process any @Import annotations
      // 处理@Import注解
      processImports(configClass, sourceClass, getImports(sourceClass), true);
   
      // Process any @ImportResource annotations
      // 处理@ImportResource注解
      AnnotationAttributes importResource =
            AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ImportResource.class);
      if (importResource != null) {
         String[] resources = importResource.getStringArray("locations");
         Class<? extends BeanDefinitionReader> readerClass = importResource.getClass("reader");
         for (String resource : resources) {
            String resolvedResource = this.environment.resolveRequiredPlaceholders(resource);
            configClass.addImportedResource(resolvedResource, readerClass);
         }
      }
   
      // Process individual @Bean methods
      Set<MethodMetadata> beanMethods = retrieveBeanMethodMetadata(sourceClass);
      for (MethodMetadata methodMetadata : beanMethods) {
         configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass));
      }
   
      // Process default methods on interfaces
      processInterfaces(configClass, sourceClass);
   
      // Process superclass, if any
      if (sourceClass.getMetadata().hasSuperClass()) {
         String superclass = sourceClass.getMetadata().getSuperClassName();
         if (superclass != null && !superclass.startsWith("java") &&
               !this.knownSuperclasses.containsKey(superclass)) {
            this.knownSuperclasses.put(superclass, configClass);
            // Superclass found, return its annotation metadata and recurse
            return sourceClass.getSuperClass();
         }
      }
   
      // No superclass -> processing is complete
      return null;
   }
   ```

   1. 可以看到在代码的上半部分处理的是`@ComponentScan`的注解，我们先来看这个方法`Set<BeanDefinitionHolder> scannedBeanDefinitions =
                     this.componentScanParser.parse(componentScan, `里面发生了什么
   
      ```java
      public Set<BeanDefinitionHolder> parse(AnnotationAttributes componentScan, final String declaringClass) {
         // 自己new一个scanner
         ClassPathBeanDefinitionScanner scanner = new ClassPathBeanDefinitionScanner(this.registry,
               componentScan.getBoolean("useDefaultFilters"), this.environment, this.resourceLoader);
      
         Class<? extends BeanNameGenerator> generatorClass = componentScan.getClass("nameGenerator");
         boolean useInheritedGenerator = (BeanNameGenerator.class == generatorClass);
         scanner.setBeanNameGenerator(useInheritedGenerator ? this.beanNameGenerator :
               BeanUtils.instantiateClass(generatorClass));
      
         ScopedProxyMode scopedProxyMode = componentScan.getEnum("scopedProxy");
         if (scopedProxyMode != ScopedProxyMode.DEFAULT) {
            scanner.setScopedProxyMode(scopedProxyMode);
         }
         else {
            Class<? extends ScopeMetadataResolver> resolverClass = componentScan.getClass("scopeResolver");
            scanner.setScopeMetadataResolver(BeanUtils.instantiateClass(resolverClass));
         }
      
         scanner.setResourcePattern(componentScan.getString("resourcePattern"));
      
         for (AnnotationAttributes filter : componentScan.getAnnotationArray("includeFilters")) {
            for (TypeFilter typeFilter : typeFiltersFor(filter)) {
               scanner.addIncludeFilter(typeFilter);
            }
         }
         for (AnnotationAttributes filter : componentScan.getAnnotationArray("excludeFilters")) {
            for (TypeFilter typeFilter : typeFiltersFor(filter)) {
               scanner.addExcludeFilter(typeFilter);
            }
         }
      
         boolean lazyInit = componentScan.getBoolean("lazyInit");
         if (lazyInit) {
            scanner.getBeanDefinitionDefaults().setLazyInit(true);
         }
      
         Set<String> basePackages = new LinkedHashSet<>();
         String[] basePackagesArray = componentScan.getStringArray("basePackages");
         for (String pkg : basePackagesArray) {
            String[] tokenized = StringUtils.tokenizeToStringArray(this.environment.resolvePlaceholders(pkg),
                  ConfigurableApplicationContext.CONFIG_LOCATION_DELIMITERS);
            Collections.addAll(basePackages, tokenized);
         }
         for (Class<?> clazz : componentScan.getClassArray("basePackageClasses")) {
            basePackages.add(ClassUtils.getPackageName(clazz));
         }
         if (basePackages.isEmpty()) {
            basePackages.add(ClassUtils.getPackageName(declaringClass));
         }
      	 // 排除例外
         scanner.addExcludeFilter(new AbstractTypeHierarchyTraversingFilter(false, false) {
            @Override
            protected boolean matchClassName(String className) {
               return declaringClass.equals(className);
            }
         });
         // 扫描包
         return scanner.doScan(StringUtils.toStringArray(basePackages));
      }
      ```
   
      可以看到spring在这个方法里面new 一个扫描器，可见我们上面说的是对的。继续到`doScan`方法
   
      ```java
      protected Set<BeanDefinitionHolder> doScan(String... basePackages) {
         Assert.notEmpty(basePackages, "At least one base package must be specified");
         Set<BeanDefinitionHolder> beanDefinitions = new LinkedHashSet<>();
         for (String basePackage : basePackages) {
            // 扫描basePackage路径下的java文件，符合条件的并把它装换成bd类型，利用ASM技术，其实就是构造路径，读取路径下的clas文件
            Set<BeanDefinition> candidates = findCandidateComponents(basePackage);
            for (BeanDefinition candidate : candidates) {
               // 解析scope属性
               ScopeMetadata scopeMetadata = this.scopeMetadataResolver.resolveScopeMetadata(candidate);
               candidate.setScope(scopeMetadata.getScopeName());
               String beanName = this.beanNameGenerator.generateBeanName(candidate, this.registry);
               if (candidate instanceof AbstractBeanDefinition) {
                  // 给bd增加一些默认的属性，比如lazy/scope
                  // 因为每一个bd都是这个类的子类，所以都会走这个方法
                  postProcessBeanDefinition((AbstractBeanDefinition) candidate, beanName);
               }
               if (candidate instanceof AnnotatedBeanDefinition) {
                  // 如果是注解的bd就把注解里面的对应的属性加上，没有就给默认的
                  AnnotationConfigUtils.processCommonDefinitionAnnotations((AnnotatedBeanDefinition) candidate);
               }
               if (checkCandidate(beanName, candidate)) {
                  BeanDefinitionHolder definitionHolder = new BeanDefinitionHolder(candidate, beanName);
                  definitionHolder =
                        AnnotationConfigUtils.applyScopedProxyMode(scopeMetadata, definitionHolder, this.registry);
                  beanDefinitions.add(definitionHolder);
                  // 注册到bdmap里面
                  registerBeanDefinition(definitionHolder, this.registry);
               }
            }
         }
         return beanDefinitions;
      }
      ```
   
      这个扫描类的其实是使用了`ASM`技术，这个技术很复杂，这儿就不细说了，其实就是通过路径去解析`class`文件，然后转换成我们的bd，接着就对bd加一些个默认的属性，如果是注解的bd就再根据注解上面的属性去覆盖这些属性。
   
   2. 另一段代码是解析`@Import`注解，`@Import`里面可以注入3种类，`普通类`、`ImportSelector.class`、`ImportBeanDefinitionRegistar.class`我们先举个`ImportSelector.class`的例子
   
      1. 定义一个接口`Dao`
     
         ```java
         public interface Dao {
         
             public void sayHello();
         }
         ```
      
      2. 定义它的实现类`IndexDao`
     
         ```java
         @Component
         public class IndexDao implements Dao {
         
             public void sayHello() {
                 System.out.println("Hello");
             };
         }
         ```
      
      3. 定义一个`ImportSelector`类
     
         ```java
         public class MyImportSelect implements ImportSelector {
             @Override
             public String[] selectImports(AnnotationMetadata annotationMetadata) {
                 return new String[]{MyBeanPostProcessor.class.getName()};
             }
         }
         ```
      
      4. 使用`BeanPostProcessor`生成代理
     
         ```java
         public class MyBeanPostProcessor implements BeanPostProcessor {
         
             @Override
             public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException {
                 if ("indexDao".equals(beanName)) {
                     bean = Proxy.newProxyInstance(this.getClass().getClassLoader(), new Class[]{Dao.class}, new MyInvocationHandler(bean));
                 }
                 return bean;
             }
         }
         ```
      
      5. 看一下代理逻辑
     
         ```java
         public class MyInvocationHandler implements InvocationHandler {
         
             private Object target;
         
             public MyInvocationHandler(Object target) {
                 this.target = target;
             }
         
             @Override
             public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
                 System.out.println("我被代理了");
                 return method.invoke(target, args);
             }
         }
         ```
      
      6. 我们的配置类引入
     
         ```java
         @Configuration
         @Import(MyImportSelect.class)
         @ComponentScan(basePackages = "com.px.spring")
         public class AppConfig {
         }
         ```
      
      7. 测试调用
     
         ```java
         public class App {
         
             public static void main(String[] args) {
                 AnnotationConfigApplicationContext context =
                         new AnnotationConfigApplicationContext(AppConfig.class);
                 // 不能用IndexDao来接，因为indexDao被代理了
               	Dao dao = (Dao) context.getBean("indexDao");
                 dao.sayHello();
         
             }
         }
         ```
      
      8. 结果
     
         ````
         我被代理了
         Hello
         ````
      
      
   可见这么也可以把bean注入进去，这样我们可以在注入bean之前进行一些个逻辑判断，选择性的注入bean。`其实我们常说的IOC容器是DefaultSingletonBeanRegistry类里面的一个ConcurrentHashMap`。
      
   `private final Map<String, Object> singletonObjects = new ConcurrentHashMap<>(256);`
      
   狭义的说来就是这个`Map`，所以在Spring里面还有这么一个map，就是这个map来存储bean的单例`Instance`。
      
   其实这里只是演示了`ImportSelector`的作用，只是用了后置处理器`BeanPostProcessor`来干预bd实例化的过程（代理了一下）。
      
   至于Spring是怎么解析这个`ImportSelector`，其实还是反射。具体代码还是得细看。这个就不做描述了。
      
      剩下的内容请看下一个文档。

## 2、Spring的后置处理器

在Spring上下文初始化的时候，注册我们自己的配置类`AppConfig.class`到`BeanDefinitionMap`里面的时候，与此同时也有6 7个类也被注册进入了Map，那么这几个类是怎么注册进来的了？

其实Spring提供了好几种方式让我们插手bean的实例化过程，其中一种就是后置处理器，即`PostProcessor`

### 使用方式

通过实现`BeanFactoryPostProcessor`类，重写方法来实现，比如

```java
/**
	Spring的扩展点之一
	实现该接口，可以在Spring的bean创建之前修改bean的定义属性
	spring允许BeanFactoryPostProcessor在容器实例化任何其他bean之前读取配置元数据
	并可以根据需要进行修改，例如可以吧bean的scope从singleton修改prototype，也可以修改其他属性
	BeanFactoryPostProcessor是在Spring容器加载了Bean的定义为文件之后，简单说就是beanDefinition之后，在bean实例化之前执行的
	这是一个简单的例子
**/
public class MyProcessor implements BeanFactoryPostProcessor {

    @Override
    public void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) throws BeansException {
        AnnotatedBeanDefinition annotatedBeanDefinition
            = (AnnotatedBeanDefinition) beanFactory.getBeanDefinition("indexDao");
        annotatedBeanDefinition.setScope("prototype");
    }
}
```

但是如果不托管给spring是不生效的，只有在

```java
context.addBeanFactoryPostProcessor(new MyProcessor());
```

的时候才生效，这是我们自己定义的后置处理器，在上面的`refresh()`的时候会得到进行一个处理。