要保证消息发送成功，就要保证生产者发送消息到交换机中，还要保证消息从交换机发送到队列中。

如果使用事务，对性能的消耗很大。

## 如何确定消息发送到了交换机

### 发送方确认

确认消息到达了交换机

1.在发送方开启消息确认

```java
@Bean
public ConnectionFactory connectionFactory() {
    CachingConnectionFactory cachingConnectionFactory
        = new CachingConnectionFactory("192.168.188.128", 5672);
    cachingConnectionFactory.setUsername("ly");
    cachingConnectionFactory.setPassword("ly");
    cachingConnectionFactory.setVirtualHost("testhost");
    // 是否开启消息确认机制
    cachingConnectionFactory.setPublisherConfirms(true);
    return  cachingConnectionFactory;
}
```

在yml文件中这样配置

```yml
spring:
  rabbitmq:
    publisher-confirms: true
```

在发送方中声明`redisTempalate`的时候加入回调

```java
@Bean
public RabbitTemplate rabbitTemplate() {
    RabbitTemplate rabbitTemplate = new RabbitTemplate();
    rabbitTemplate.setConnectionFactory(connectionFactory());
    // 发送方确认回调
    rabbitTemplate.setConfirmCallback((crrelationData, ack, cause) -> {
        // crrelationData 可以发送业务id
        // ack 消息是否发送成功
        // cause 失败的原因
    });
    return rabbitTemplate;
}
```

可以通过spring的方式来模拟失败的情况

````java
public static void main(String[] args) {
    AnnotationConfigApplicationContext context
        = new AnnotationConfigApplicationContext(RabbitmqConfig.class);
    RabbitmqMessageSend bean 
        = context.getBean(RabbitmqMessageSend.class);
    bean.sendMessage("", "", "");
    context.close();
}
````



### 失败回调

在消息从交换机到达队列的时候，如果失败了会调用一个失败回调方法

1. 同样的需要打开消息确认的功能，在发送方生成连接的时候打开

   ```java
    // 是否开启消息确认机制
   cachingConnectionFactory.setPublisherConfirms(true);
   ```

2. 同样在发送方的`rabbittemplate`的地方加入回调方法

   ```java
   // 开启失败回调
   rabbitTemplate.setMandatory(true);
   rabbitTemplate.setReturnCallback(new RabbitTemplate.ReturnCallback() {
       @Override
       public void returnedMessage(Message message, int replyCode, String replyText, String exchange, String routeKey) {
           // message：发送的消息和消息的配置
           // replayCode：状态码
           // replayText: 失败的信息
           // exchange:  交换机
           // routeKey: 路由键
       }
   });
   ```

除了失败回调，rabbitmq还提供了一个备用交换机方案来解决这个问题，那么怎么声明呢？

```java
// 声明交换机
@Bean
public DirectExchange defaultExchange() {
    Map<String, Object> map  = new HashMap<>();
    // 声明备用交换机
    map.put("alternate-exchange", "exchangeTest");
    return new DirectExchange("directExchange", false/*是否持久化*/, false/*是否自动删除*/, map);
}
```

在声明交换机的时候附带一个备用交换机,一般备用交换机是fanout的类型，只要绑定了就会发送消息到队列上。`如果备用交换机失败了才会调用失败回调`

```
如果有备用交换机，不会管主要交换机绑定与否，只要备用交换机绑定就好了
```

```
发送方确认模式一般也会和失败回调一起使用 这样 就能确保消息100%投递了
```

## 发送消息

如果要发送一个对象怎么办？

如果使用spring boot 自己的序列化挺没有用的，我们采用`fastjson`来发送对象

发送一个map对象

````java
public void sendMessage(String message, String routingKey, String name) {
    // 发送map
    Map<String, Object> messageMap = new HashMap<String, Object>();
    messageMap.put("name", "123");
    messageMap.put("password", "123456");
    rabbitTemplate.convertAndSend(name, routingKey, JSON.toJSONString(messageMap));
}
````

在消费方可以通过``JSON.Parse()``来转换回原来的map

如何去定义一个消息转换器

```java
// 声明消息转换器
rabbitTemplate.setMessageConverter(new MessageConverter() {
    // 发送时需要转换的
    @Override
    public Message toMessage(Object o, MessageProperties messageProperties) throws MessageConversionException {
        // 传送消息是通过byte所以需要转换成byte
        Message message = new Message(JSON.toJSONBytes(o), messageProperties);
        return message;
    }
    // 接受消息的时候需要转换的
    @Override
    public Object fromMessage(Message message) throws MessageConversionException {
        return null;
    }
});
```

但是如果通过以下`消费者`的方式去接收的时候

```java
@RabbitListener(queues = "query1")
public void get(String message) throws Exception {
    System.out.println(message);
}
```

结果为`byte数组`

为什么是这样的结果？

出现这个问题是spring boot 给你转换了，下面我们要通过源码来分析为什么会出现这个问题

我们通过`方法的调用栈`来回头一步一步来找到对应的方法，我这儿就截取核心代码

通过调用的方法栈，回头一步一步发现在`SimpleMessageConverter`这个类下面的`fromMessage`方法来转换消息

```java
public Object fromMessage(Message message) throws MessageConversionException {
    Object content = null;
    MessageProperties properties = message.getMessageProperties();
    if (properties != null) {
        String contentType = properties.getContentType();
        // 如果这个contengType是文本的时候才转换
        if (contentType != null && contentType.startsWith("text")) {
            String encoding = properties.getContentEncoding();
            if (encoding == null) {
                encoding = this.defaultCharset;
            }

            try {
                content = new String(message.getBody(), encoding);
            } catch (UnsupportedEncodingException var8) {
                throw new MessageConversionException("failed to convert text-based Message content", var8);
            }
        } else if (contentType != null && contentType.equals("application/x-java-serialized-object")) {
            try {
                content = SerializationUtils.deserialize(this.createObjectInputStream(new ByteArrayInputStream(message.getBody()), this.codebaseUrl));
            } catch (IllegalArgumentException | IllegalStateException | IOException var7) {
                throw new MessageConversionException("failed to convert serialized Message content", var7);
            }
        }
    }
	// 什么条件都不满足，就直接返回content
    if (content == null) {
        content = message.getBody();
    }

    return content;
}
```

```
由上可见，如果消息的properties里面的contentType[上下文类型]是text或者application都会帮你转换，但是我们这儿的map不是这些类型所以就直接返回了，所以是byte数组
```

所以我们在发送消息的时候设置消息配置

````java
rabbitTemplate.setMessageConverter(new MessageConverter() {
    // 发送时需要转换的
    @Override
    public Message toMessage(Object o, MessageProperties messageProperties) throws MessageConversionException {
        // 传送消息是通过byte所以需要转换成byte
        messageProperties.setContentType("text/xml"); // 设置这一句
        Message message = new Message(JSON.toJSONBytes(o), messageProperties);
        return message;
    }
    // 接受消息的时候需要转换的
    @Override
    public Object fromMessage(Message message) throws MessageConversionException {
        return null;
    }
});
````

通过`messageProperties.setContentType("text/xml");`设置了上下文类型，就会进行一个`new Message()`的转换





