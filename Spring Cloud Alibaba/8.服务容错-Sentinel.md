## 雪崩效应

看下图，如果一个服务挂了，后面一连个服务都接连崩溃。基层服务故障导致上层服务故障，并且这个故障不断放大的过程叫做**雪崩效应**，英文：`Cascading Fading`

![](./img/62.png)

## 常见容错方案

+ 超时

  如果为每次请求设置比较短的超时时间，不管这次请求是否成功，那么到时就就会释放资源，如果释放够快，就不会被拖死。

+ 限流

  限定QPS数量，如果QPS超过了就不予访问。

+ 仓壁模式

  让每个请求都有独立的线程池，如果线程池没有线程就只有排队，如果排队也没有容量了就使用线程池的饱和策略。

+ 断路器模式

  断路器模式说白了就是监控和开关，如果一个API一定时间内的错误率达到阈值，我们就认为所依赖的服务是不可用的，就跳闸，就不去调用，假设后来恢复正常，断路器模式设计了一种半开状态，如下图：

  ![](./img/63.png)

## 使用Sentinel实现容错

### Sentinel是什么？

官网说Sentinel是轻量的流量控制、熔断降级Java库

### 整合Sentinel

```xml
<dependency>
   <groupId>org.springframework.cloud</groupId>
   <artifactId>spring-cloud-starter-alibaba-sentinel</artifactId>
</dependency>
```

只需要加上依赖就可以了。那么我们怎么可以确认我们的应用受Sentinel的保护呢？如果加入actuator的依赖就会暴露一个/actuator/sentinel的端点，下面我们来试试。

```xml
<dependency>
   <groupId>org.springframework.boot</groupId>
   <artifactId>spring-boot-starter-actuator</artifactId>
</dependency>
```

为了查看所有的端点，需要在yml文件中加入以下配置。

```yml
management:
  endpoints:
    web:
      exposure:
        include: '*'
```

网页访问`http://localhost:2000/actuator/sentinel`

````json
{
	"blockPage": null,
	"appName": "content-center",
	"consoleServer": null,
	"coldFactor": "3",
	"rules": {
		"systemRules": [],
		"authorityRule": [],
		"paramFlowRule": [],
		"flowRules": [],
		"degradeRules": []
	},
	"metricsFileCharset": "UTF-8",
	"filter": {
		"order": -2147483648,
		"urlPatterns": ["/*"],
		"enabled": true
	},
	"totalMetricsFileCount": 6,
	"datasource": {},
	"clientIp": "192.168.31.41",
	"clientPort": "8719",
	"logUsePid": false,
	"metricsFileSize": 52428800,
	"logDir": "/Users/litian/logs/csp/",
	"heartbeatIntervalMs": 10000
}
````

说明端点确实整合了sentinel，关键是这些都是些什么玩意儿，各位看官接着往下看。

## Sentinel控制台

### 搭建Sentinel控制台

访问：https://github.com/alibaba/Sentinel/releases，选择对应的版本，至于选择什么版本需要看我们引入的Sentinel的版本。建议生产环境下sentinel的版本和控制台的版本保持一致。我这儿是1.5.2，我们这儿使用1.6.2的版本也能兼容。下载完成后用java -jar命令启动就行了。默认端口是8080，访问`localhost:8080`就行了，1.6.2版本新增了登录界面，如下：

![](./img/64.png)

用户名和密码都是sentinel，登录后页面如下：

![](./img/65.png)

**Sentinel和Ribbon一样默认是懒加载**，只有在访问了之后页面才会有显示，至于如何整合应用，请接着往下看。

### 整合应用&控制台

![](./img/66.png)

访问微服务后，控制台才会显示。

![](./img/67.png)

## Sentinel流控规则

在控制台的簇点链路里面可以看到访问过的路径，点击流控可以新增流控规则。

![](./img/68.png)

![](./img/69.png)

+ **资源名**：控制台会自动填写路径，其实就是唯一的一个名称

+ **针对来源**：可以针对不同的微服务有不同的规则，default表示不区分来源，区分来源需要做扩展

+ **阈值类型**：

+ **是否集群**：暂留悬念

+ **流控模式**：

  + **直接**：如果达到阈值就直接限流，比如我这儿直接测试的是qps是1的情况

    ![](./img/70.png)

  + **关联**：当关联的资源达到阈值就限流自己

    这儿用/actuator/sentinel这个链接来测试

    ![](./img/71.png)

    ```java
    public static void main(String[] args) {
       RestTemplate restTemplate = new RestTemplate();
       for (int i = 0; i < 1000; i++) {
          restTemplate.getForObject("http://localhost:2000/actuator/sentinel", String.class);
          try {
             Thread.sleep(500);
          } catch (InterruptedException e) {
             e.printStackTrace();
          }
       }
    }
    ```

    测试的时候确实达到了关联的效果

    适用场景：如果一个查询接口关联修改接口，如果查询过快就会导致修改承受不住，所以为了保护关联资源，我们就需要去限流

  + **链路**：只记录指定链路上的流量

    做个实验，在controller里面加上两个方法，然后都调用service的某个方法，这个方法加上了`@sentinelResource`注解，下面配上代码以及链路控制的图

    ```java
    @Resource
    private TestService testService;
    
    @GetMapping(value = "test-a")
    public String testA() {
        testService.common();
        return "test-a";
    }
    
    @GetMapping(value = "test-b")
    public String testb() {
        testService.common();
        return "test-b";
    }
    ```

    ```java
    @Service
    @Slf4j
    public class TestService {
    
        @SentinelResource("common")
        public String common() {
            log.info("common");
            return "common";
        }
    }
    ```

    ![](./img/72.png)

    测试结果达到预期。test-a超过qps就限流，而test-b不会被限流。

+ **流控效果**：

  + 快速失败

    + 直接失败，抛异常
    + 相关源码：com.alibaba.csp.sentinel.slots.bock.flow.controller.DefaultControlle

  + Waring UP

    根据codeFactor(默认3)的值，从阈值/codeFactor，经过预热时长，才达到设置的QPS阈值。意思是刚开始的阈值是阈值除以codeFactor，经过预热时长，才达到设置的QPS阈值。

    ![](./img/73.png)

    这个适用于某个微服务，某一时刻流量激增，如果不做处理，就会把这个微服务崩掉。

    官方也有文档分析，可以自己去找找。

    相关源码：com.alibaba.csp.sentinel.slots.flow.controller.WarmUpController

  + 排队等待

    + 匀速排队，让请求以均匀的速度通过，阈值类型必须设成QPS，否则无效，如果超过超时请求就丢弃

      ![](./img/74.png)

      适用于应对突然流量的场景，一会儿来很多，一会儿空闲，如果希望空闲下来处理这些请求，就可以使用这种模式。

      官方也有相关文档，对应源码：com.alibaba.csp.sentinel.slots.block.flow.controller.RateLimiterController

## 降级规则详解

相当于流控，降级规则要简单很多，但是有很多细节要注意。

![](./img/75.png)

RT就是平均响应时间，上图意思是

![](./img/76.png)

![](./img/77.png)

![](./img/78.png)

![](./img/79.png)

![](./img/80.png)

**因为异常数是分钟统计，如果时间窗口小于60秒可能会一直降级**

![](./img/81.png)

![](./img/82.png)

## 热点规则

热点规则针对不同参数，可以进行不同的限流。做个实验：

```java
@GetMapping(value = "/testHot")
@SentinelResource("hot")
public String test(@RequestParam(value = "a", required = false) String a,
                   @RequestParam(value = "b", required = false) String b) {
    return a + b;
}
```

![](./img/84.png)

当参数a的值不是4时超过单机阈值1时就会限流，倘若不给值就不会被限流，同样的如果a的值是4的话，只要不超过100，也同样不限流。

![](./img/83.png)

## 系统规则

![](./img/85.png)

### 系统LOAD（负载）

当系统load1（1分钟load）超过阈值，且并发线程数超过**系统容量**时触发，建议设置为CPU核心数*2.5。（仅对LINUX/Unix-like机器生效）

在linux系统里面执行`uptime`命令就可以查看load

![](./img/86.png)

以上三个数字分别对应1分钟的系统平均负载，5分钟的系统平均负载，15分钟的系统平均负载

上面提到了系统容量，那么什么是系统容量

+ 系统容量 = maxQps * minRt
  + maxQps: 秒级统计出来的最大QPS
  + minRt：秒级统计出来的最小响应时间
  + 相关源码：com.alibaba.csp.sentinel.slots.system.SystemRuleManger#checkBbr

![](./img/87.png)

![](./img/88.png)

## 授权规则

![](./img/89.png)

上图意思很简单，就是将调用该资源的服务（流控应用）设置为白名单或者黑名单，**在流控规则的时候我们看到了针对来源，说了如果要使用针对来源需要进行扩展，目前可以把授权规则暂留印象，后面会进一步深入。**

## 代码规则配置

http://www.imooc.com/article/289345

但是代码配置意义不大，但是对于扩展sentinel意义很大。

## Sentinel与控制台通信原理

+ 控制台是如何获取到微服务的监控信息的？
+ 用控制台配置规则时，控制台是如何将规则发送到各个微服务的呢？ 

### Sentinel - 控制台 通信

![](./img/90.png)如上图Sentinel实现了一套服务发现机制。在控制台可以看到微服务地址：

![](./img/91.png)

上面的ip地址和端口号是微服务和控制台之间通信的端口号和地址。

通过第一个图我们知道：微服务将自己注册到sentinel的控制台，sentinel控制台想要获取微服务的监控信息 通过定时请求微服务上面的监控API，想要推送规则给微服务，控制台就去调用微服务上面接收规则的API就可以，那么都是些什么API呢？

通过ip地址和端口就可以看到：



![](./img/93.png)

### 通信源码

![](./img/92.png)

## 应用端连接控制台配置项

### 应用端配置项

![](./img/94.png)

### 控制台配置项

![](./img/95.png)

其中标注1.6的是1.6版本的控制台新增的，使用方式在启动控制台时增加相关的命令，比如

```java
java -jar -Dsentinel.dashboard.auth.username=sentinel -Dsentinel.dashboard.auth.password=123456 sentinle.....jar 
```

## Sentinel API详解

一个小例子

为了防止干扰，我们关闭对SpringMVC端点的保护

```java
sentinel:
  filter:
    # 关闭掉对SpringMVC端点的保护
    enabled: false
```

添加测试代码：

```java
@GetMapping(value = "test-sentinel-api")
public String testSentinelAPI(@RequestParam(required = false) String a) {
    // 定义一个sentinel保护的资源
    try (Entry entry = SphU.entry("test-sentinel-api");){
        if (StringUtils.isBlank(a)) {
            throw new IllegalArgumentException("a不能为空");
        }
         // 保护的业务逻辑
        return a;
        // 如果被保护的资源被限流或者降级了就会抛异常
    } catch (BlockException e) {
        log.warn("限流后者降级了", e);
        return "限流后者降级了";
    } catch (IllegalArgumentException e2) {
        // Sentinel默认只统计BlockException或者其子类，为了统计IllegalArgumentException，需要加入如下代码
        // 主要统计发生的次数，发生占比
        Tracer.trace(e2);
        return "参数非法";
    }
}
```

在页面添加流控规则：

![](./img/99.png)

访问了几次后成功打印出限流信息

![](./img/100.png)

为了统计异常我们增加降级规则：

![](./img/101.png)

如果不传递参数，页面也成功打印出了降级信息，这儿要说一句就是，如果配置了降级规则必须要配置流控规则

接着我们看下流控规则的针对来源，我们对代码做进一步处理

```java
@GetMapping(value = "test-sentinel-api")
public String testSentinelAPI(@RequestParam(required = false) String a) {
    String resourceName = "test-sentinel-api";
    // 定义一个sentinel保护的资源
    try (Entry entry = SphU.entry(resourceName);){
        ContextUtil.enter(resourceName, "test-wfw");
        if (StringUtils.isBlank(a)) {
            throw new IllegalArgumentException("a不能为空");
        }
         // 保护的业务逻辑
        return a;
        // 如果被保护的资源被限流或者降级了就会抛异常
    } catch (BlockException e) {
        log.warn("限流后者降级了", e);
        return "限流后者降级了";
    } catch (IllegalArgumentException e2) {
        // Sentinel默认只统计BlockException或者其子类，为了统计IllegalArgumentException，需要加入如下代码
        // 主要统计发生的次数，发生占比
        Tracer.trace(e2);
        return "参数非法";
    } finally {
        ContextUtil.exit();
    }
}
```

在流控规则中增加针对来源部分后测试，不过我这儿测试不通过，很诡异。

针对其他API请查看官方文档(https://github.com/alibaba/Sentinel/wiki/如何使用)

## @SentinelResources详解

将上面的代码使用注解实现：

```java
@GetMapping(value = "test-sentinel-resource")
@SentinelResource(value = "test-sentinel-resource",
        blockHandler = "block", fallback = "fallback")
public String testSentinelResource(@RequestParam(required = false) String a) {
    if (StringUtils.isBlank(a)) {
        throw new IllegalArgumentException("a不能为空");
    }
    // 保护的业务逻辑
    return a;
}

/**
 * 主要处理服务限流或者降级
 * @param a
 * @return
 */
public String block(String a, BlockException e) {
    log.warn("服务限流了", e);
    return "服务限流了";
}

/**
 * 1.5版本处理服务降级
 	 1.6可以处理Throwable
 * @param a
 * @return
 */
public String fallback(String a) {
    return "服务降级了";
}
```

+ blockHandler: 主要处理服务限流或者降级，比如流控规则或者降级规则都可以在这儿处理。
+ fallback ：主要处理降级。1.6版本后可以处理Throwable

那么如果我的类非常大，如果把限流或者降级的方法弄进去就会更加庞大。这时候可以使用`blockHandlerClass`

```java
@SentinelResource(value = "test-sentinel-resource",
        blockHandler = "block",
        blockHandlerClass = TestSentinelBlock.class,
        fallback = "fallback")
```

```java
@Slf4j
public class TestSentinelBlock {

    /**
     * 主要处理服务限流或者降级
     * @param a
     * @return
     */
    public static String block(String a, BlockException e) {
        log.warn("服务限流了", e);
        return "服务限流了";
    }
}
```

**注意，方法需要加上static参数。**

## RestTemplate整合Sentinel

```java
@Bean
@LoadBalanced
@SentinelRestTemplate
public RestTemplate restTemplate() {
   return new RestTemplate();
}
```

我们写一个测试接口：

```java
@Autowired
private RestTemplate restTemplate;

@GetMapping(value = "/test-restTemplate-sentinel/{id}")
public UserDto testRestTemplateSentinle(@PathVariable Integer id) {
    return restTemplate.getForObject("http://user-center/users/{id}", UserDto.class, id);
}
```

页面访问成功，我们再看一下sentinel的控制台的簇点链路

![](./img/102.png)

新增流控规则后，访问页面成功进行了限流：

![](./img/103.png)

如果不想让sentinel监控resttemplate，sentinel还提供了一个开关：

```yml
resttemplate:
  sentinel:
    # 关闭@SentinelRestTemplate注解
    enabled: false
```

如果配置了上面的选项，那么簇点链路将不会检测到对应的url。那么这个配置适用于什么场景呢，当我们在测试的时候，我们不希望sentinel的监控，不需要sentinel的降级和限流的时候就可以使用。

在上图我们看到限流后页面打印的是异常信息，如果要做进一步的处理可以参考`@SentinelResource`的配置，因为`@SentinelRestTemplate`和`@SentinelResource`基本一致。如下：

```
@Target({ElementType.METHOD})
@Retention(RetentionPolicy.RUNTIME)
@Documented
public @interface SentinelRestTemplate {
    String blockHandler() default "";

    Class<?> blockHandlerClass() default void.class;

    String fallback() default "";

    Class<?> fallbackClass() default void.class;
}
```

### 相关源码

org.springframework.cloud.alibaba.sentinel.custom.SentinelBeanPostProcessor

这个源码强烈建议看看，里面有很多知识点，包括Spring的后置处理器，以及一些反射的知识。

## Feign整合Sentinel

### 配置

只需要加入`feign.sentinel.enabaled = true`就好了。

重启服务后在sentinel的控制台簇点链路显示对应的连接，增加流控规则后成功拦截，但是页面显示不美观。

![](./img/104.png)

### 自定义限流逻辑

那么限流降级发生时，如何定制自己的处理逻辑？

```java
@FeignClient(name = "user-center", fallback = UserCenterFeignFallBack.class)
public interface UserCenterFeignClient {

    /**
     * Feign构造如下的url:
     * http://user-center/users/{id}
     * @param id
     * @return
     */
    @GetMapping(value = "/users/{id}")
    UserDto findById(@PathVariable Integer id);
}
```

在FeignClient上面指定fallback

```java
/**
 * 一定加上component注解
 */
@Component
public class UserCenterFeignFallBack implements UserCenterFeignClient {


    @Override
    public UserDto findById(Integer id) {
        UserDto userDto = new UserDto();
        userDto.setWxNickname("一个默认用户");
        return userDto;
    }
}
```

一定要加上compoent注解。

重新启动应用测试成功：

````json
{
	"id": 1,
	"userId": 1,
	"title": "Sring Boot简介",
	"createTime": "2019-12-09T09:44:57.000+0000",
	"updateTime": "2019-12-09T09:44:57.000+0000",
	"isOriginal": false,
	"author": "??",
	"cover": "111",
	"summary": "",
	"price": 0,
	"downloadUrl": "",
	"buyCount": 1,
	"showFlag": false,
	"auditStatus": "0",
	"reason": "",
	"wxNickname": "一个默认用户"
}
````

### 捕获异常

如何获得异常？实际开发的时候我们需要获取到异常来定位问题。使用`@FeignClient`里面的fallbackfactory属性，**注意：fallbackFactory比fallback强大点，但是它们不能共存。**

```java
@FeignClient(name = "user-center", fallbackFactory = UserCenterFeignFallBackFactory.class)
```

```java
/**
 * @author litian
 */
@Component
@Slf4j
public class UserCenterFeignFallBackFactory implements FallbackFactory<UserCenterFeignClient> {
    @Override
    public UserCenterFeignClient create(Throwable cause) {
        return new UserCenterFeignClient() {
            @Override
            public UserDto findById(Integer id) {
                // 打印异常信息
                log.warn("远程调用被限流或者降级了", cause);
                UserDto userDto = new UserDto();
                userDto.setWxNickname("一个默认用户");
                return userDto;
            }
        };
    }
}
```

### 相关源码

org.springframework.cloud.alibaba.sentinel.feign.Sentinel

## Sentinel使用姿势总结

![](./img/105.png)

## 规则持久化-拉模式

前面测试只要应用重启，规则便会消失，这儿咱们来探讨如何让规则持久化。

关于持久化，sentinel提供了两种模式，一种是推，一种是拉，咱们先来探讨拉模式。

### 1.拉模式架构

![](./img/106.png)

### 2.原理简述

+ FileRefreshableDataSource **定时**从指定文件中读取规则JSON文件【图中的本地文件】，如果发现文件发生变化，就更新规则缓存。
+ FileWritableDataSource 接收控制台规则推送，并根据配置，修改规则JSON文件【图中的本地文件】。

### 3.编写

修改Spring Cloud Alibaba微服务。

#### 3.1加依赖

```xml
<dependency>
  <groupId>com.alibaba.csp</groupId>
  <artifactId>sentinel-datasource-extension</artifactId>
</dependency>
```

#### 3.2写代码

```java
package com.itmuch.contentcenter.sentinelTest;

import com.alibaba.csp.sentinel.command.handler.ModifyParamFlowRulesCommandHandler;
import com.alibaba.csp.sentinel.datasource.*;
import com.alibaba.csp.sentinel.init.InitFunc;
import com.alibaba.csp.sentinel.slots.block.authority.AuthorityRule;
import com.alibaba.csp.sentinel.slots.block.authority.AuthorityRuleManager;
import com.alibaba.csp.sentinel.slots.block.degrade.DegradeRule;
import com.alibaba.csp.sentinel.slots.block.degrade.DegradeRuleManager;
import com.alibaba.csp.sentinel.slots.block.flow.FlowRule;
import com.alibaba.csp.sentinel.slots.block.flow.FlowRuleManager;
import com.alibaba.csp.sentinel.slots.block.flow.param.ParamFlowRule;
import com.alibaba.csp.sentinel.slots.block.flow.param.ParamFlowRuleManager;
import com.alibaba.csp.sentinel.slots.system.SystemRule;
import com.alibaba.csp.sentinel.slots.system.SystemRuleManager;
import com.alibaba.csp.sentinel.transport.util.WritableDataSourceRegistry;
import com.alibaba.fastjson.JSON;
import com.alibaba.fastjson.TypeReference;

import java.io.File;
import java.io.IOException;
import java.util.List;

/**
 * 拉模式规则持久化
 *
 * @author itmuch.com
 */
public class FileDataSourceInit implements InitFunc {
    @Override
    public void init() throws Exception {
        // TIPS: 如果你对这个路径不喜欢，可修改为你喜欢的路径
        String ruleDir = System.getProperty("user.home") + "/sentinel/rules";
        String flowRulePath = ruleDir + "/flow-rule.json";
        String degradeRulePath = ruleDir + "/degrade-rule.json";
        String systemRulePath = ruleDir + "/system-rule.json";
        String authorityRulePath = ruleDir + "/authority-rule.json";
        String paramFlowRulePath = ruleDir + "/param-flow-rule.json";

        this.mkdirIfNotExits(ruleDir);
        this.createFileIfNotExits(flowRulePath);
        this.createFileIfNotExits(degradeRulePath);
        this.createFileIfNotExits(systemRulePath);
        this.createFileIfNotExits(authorityRulePath);
        this.createFileIfNotExits(paramFlowRulePath);

        // 流控规则
        ReadableDataSource<String, List<FlowRule>> flowRuleRDS = new FileRefreshableDataSource<>(
            flowRulePath,
            flowRuleListParser
        );
        // 将可读数据源注册至FlowRuleManager
        // 这样当规则文件发生变化时，就会更新规则到内存
        FlowRuleManager.register2Property(flowRuleRDS.getProperty());
        WritableDataSource<List<FlowRule>> flowRuleWDS = new FileWritableDataSource<>(
            flowRulePath,
            this::encodeJson
        );
        // 将可写数据源注册至transport模块的WritableDataSourceRegistry中
        // 这样收到控制台推送的规则时，Sentinel会先更新到内存，然后将规则写入到文件中
        WritableDataSourceRegistry.registerFlowDataSource(flowRuleWDS);

        // 降级规则
        ReadableDataSource<String, List<DegradeRule>> degradeRuleRDS = new FileRefreshableDataSource<>(
            degradeRulePath,
            degradeRuleListParser
        );
        DegradeRuleManager.register2Property(degradeRuleRDS.getProperty());
        WritableDataSource<List<DegradeRule>> degradeRuleWDS = new FileWritableDataSource<>(
            degradeRulePath,
            this::encodeJson
        );
        WritableDataSourceRegistry.registerDegradeDataSource(degradeRuleWDS);

        // 系统规则
        ReadableDataSource<String, List<SystemRule>> systemRuleRDS = new FileRefreshableDataSource<>(
            systemRulePath,
            systemRuleListParser
        );
        SystemRuleManager.register2Property(systemRuleRDS.getProperty());
        WritableDataSource<List<SystemRule>> systemRuleWDS = new FileWritableDataSource<>(
            systemRulePath,
            this::encodeJson
        );
        WritableDataSourceRegistry.registerSystemDataSource(systemRuleWDS);

        // 授权规则
        ReadableDataSource<String, List<AuthorityRule>> authorityRuleRDS = new FileRefreshableDataSource<>(
            authorityRulePath,
            authorityRuleListParser
        );
        AuthorityRuleManager.register2Property(authorityRuleRDS.getProperty());
        WritableDataSource<List<AuthorityRule>> authorityRuleWDS = new FileWritableDataSource<>(
            authorityRulePath,
            this::encodeJson
        );
        WritableDataSourceRegistry.registerAuthorityDataSource(authorityRuleWDS);

        // 热点参数规则
        ReadableDataSource<String, List<ParamFlowRule>> paramFlowRuleRDS = new FileRefreshableDataSource<>(
            paramFlowRulePath,
            paramFlowRuleListParser
        );
        ParamFlowRuleManager.register2Property(paramFlowRuleRDS.getProperty());
        WritableDataSource<List<ParamFlowRule>> paramFlowRuleWDS = new FileWritableDataSource<>(
            paramFlowRulePath,
            this::encodeJson
        );
        ModifyParamFlowRulesCommandHandler.setWritableDataSource(paramFlowRuleWDS);
    }

    private Converter<String, List<FlowRule>> flowRuleListParser = source -> JSON.parseObject(
        source,
        new TypeReference<List<FlowRule>>() {
        }
    );
    private Converter<String, List<DegradeRule>> degradeRuleListParser = source -> JSON.parseObject(
        source,
        new TypeReference<List<DegradeRule>>() {
        }
    );
    private Converter<String, List<SystemRule>> systemRuleListParser = source -> JSON.parseObject(
        source,
        new TypeReference<List<SystemRule>>() {
        }
    );

    private Converter<String, List<AuthorityRule>> authorityRuleListParser = source -> JSON.parseObject(
        source,
        new TypeReference<List<AuthorityRule>>() {
        }
    );

    private Converter<String, List<ParamFlowRule>> paramFlowRuleListParser = source -> JSON.parseObject(
        source,
        new TypeReference<List<ParamFlowRule>>() {
        }
    );

    private void mkdirIfNotExits(String filePath) throws IOException {
        File file = new File(filePath);
        if (!file.exists()) {
            file.mkdirs();
        }
    }

    private void createFileIfNotExits(String filePath) throws IOException {
        File file = new File(filePath);
        if (!file.exists()) {
            file.createNewFile();
        }
    }

    private <T> String encodeJson(T t) {
        return JSON.toJSONString(t);
    }
}
```

以上路径可以根据自己需要来选择。

#### 3.3配置

在项目的 `resources/META-INF/services` 目录下创建文件，名为 `com.alibaba.csp.sentinel.init.InitFunc` ，内容为：

```
# 改成上面FileDataSourceInit的包名类名全路径即可。
com.itmuch.contentcenter.FileDataSourceInit
```

### 4.优缺点分析

#### 4.1优点

+ 简单易懂

+ 没有多余依赖（比如配置中心、缓存等）

#### 4.2缺点

+ 由于规则是用 FileRefreshableDataSource 定时更新的，所以规则更新会有延迟。如果FileRefreshableDataSource定时时间过大，可能长时间延迟；如果FileRefreshableDataSource过小，又会影响性能；

+ 规则存储在本地文件，如果有一天需要迁移微服务，那么需要把规则文件一起迁移，否则规则会丢失。

### 5.你可能会有的疑问

```
Spring Cloud Alibaba不是提供了如下配置了吗？为什么要全部自己写呢？
```

````
spring.cloud.sentinel.datasource.ds1.file.file=classpath: degraderule.json
spring.cloud.sentinel.datasource.ds1.file.rule-type=flow

#spring.cloud.sentinel.datasource.ds1.file.file=classpath: flowrule.json
#spring.cloud.sentinel.datasource.ds1.file.data-type=custom
#spring.cloud.sentinel.datasource.ds1.file.converter-class=com.alibaba.cloud.examples.JsonFlowRuleListConverter
#spring.cloud.sentinel.datasource.ds1.file.rule-type=flow
````

请查看这个：

```
https://github.com/alibaba/spring-cloud-alibaba/issues/756
```

### 6.参考文档

```
https://github.com/alibaba/Sentinel/wiki/在生产环境中使用-Sentinel#pull模式
```

## 规则持久化-推模式

### 1.推模式架构图

![](./img/107.png)

### 2.原理简述

+ 控制台推送规则：
  + 将规则推送到Nacos或其他远程配置中心
  + Sentinel客户端链接Nacos，获取规则配置；并监听Nacos配置变化，如发生变化，就更新本地缓存（从而让本地缓存总是和Nacos一致）

+ 控制台监听Nacos配置变化，如发生变化就更新本地缓存（从而让控制台本地缓存总是和Nacos一致）

### 3.微服务改造

#### 3.1加依赖

```xml
<dependency>
   <groupId>com.alibaba.csp</groupId>
   <artifactId>sentinel-datasource-nacos</artifactId>
</dependency>
```

#### 3.2添加配置

```yml
spring:
  cloud:
    sentinel:
      datasource:
        # 名称随意
        flow:
          nacos:
            server-addr: localhost:8848
            dataId: ${spring.application.name}-flow-rules
            groupId: SENTINEL_GROUP
            # 规则类型，取值见：
            # org.springframework.cloud.alibaba.sentinel.datasource.RuleType
            rule-type: flow
        degrade:
          nacos:
            server-addr: localhost:8848
            dataId: ${spring.application.name}-degrade-rules
            groupId: SENTINEL_GROUP
            rule-type: degrade
        system:
          nacos:
            server-addr: localhost:8848
            dataId: ${spring.application.name}-system-rules
            groupId: SENTINEL_GROUP
            rule-type: system
        authority:
          nacos:
            server-addr: localhost:8848
            dataId: ${spring.application.name}-authority-rules
            groupId: SENTINEL_GROUP
            rule-type: authority
        param-flow:
          nacos:
            server-addr: localhost:8848
            dataId: ${spring.application.name}-param-flow-rules
            groupId: SENTINEL_GROUP
            rule-type: param-flow
```

### 4.控制台改造

> 控制台改造主要是为规则实现
>
> + DynamicRuleProvider：从Nacos上读取配置
>
> + DynamicRulePublisher：将规则推送到Nacos上
>
> + 
>
>
>   作者：大目
>   链接：http://www.imooc.com/article/289464
>   来源：慕课网
>   本文原创发布于慕课网 ，转载请注明出处，谢谢合作

4.1 修改pom.xml，找到：

```
<!-- for Nacos rule publisher sample -->
  <dependency>
    <groupId>com.alibaba.csp</groupId>
    <artifactId>sentinel-datasource-nacos</artifactId>
    <scope>test</scope>
  </dependency>
```

将 `test` 这一行注释掉，即改为如下：

```
<!-- for Nacos rule publisher sample -->
<dependency>
  <groupId>com.alibaba.csp</groupId>
  <artifactId>sentinel-datasource-nacos</artifactId>
  <!--<scope>test</scope>-->
</dependency>
```

找到 `sentinel-dashboard/src/test/java/com/alibaba/csp/sentinel/dashboard/rule/nacos`目录，将整个目录拷贝到 `sentinel-dashboard/src/main/java/com/alibaba/csp/sentinel/dashboard/rule/nacos`，如图：
![](./img/108.png)

修改 `com.alibaba.csp.sentinel.dashboard.controller.v2.FlowControllerV2` ，找到

```java
@Autowired
@Qualifier("flowRuleDefaultProvider")
private DynamicRuleProvider<List<FlowRuleEntity>> ruleProvider;
@Autowired
@Qualifier("flowRuleDefaultPublisher")
private DynamicRulePublisher<List<FlowRuleEntity>> rulePublisher;
```

修改为：

```java
@Autowired
@Qualifier("flowRuleNacosProvider")
private DynamicRuleProvider<List<FlowRuleEntity>> ruleProvider;
@Autowired
@Qualifier("flowRuleNacosPublisher")
private DynamicRulePublisher<List<FlowRuleEntity>> rulePublisher;
```

修改 `sentinel-dashboard/src/main/webapp/resources/app/scripts/directives/sidebar/sidebar.html`，找到：

```html
<!--<li ui-sref-active="active">-->
  <!--<a ui-sref="dashboard.flow({app: entry.app})">-->
    <!--<i class="glyphicon glyphicon-filter"></i>&nbsp;&nbsp;流控规则 V1</a>-->
<!--</li>-->
```

把注释解开，即改为：

```html
<li ui-sref-active="active">
  <a ui-sref="dashboard.flow({app: entry.app})">
    <i class="glyphicon glyphicon-filter"></i>&nbsp;&nbsp;流控规则 V1</a>
</li>
```

齐活儿啦！终于把流控规则改造成推模式持久化啦！

### 5.编译 & 启动

+ 执行 `mvn clean package -DskipTests`

+ 在项目的 `target` 目录找到`sentinel-dashboard.jar` ，执行 `java -jar sentinel-dashboard.jar` 启动控制台。

### 6.测试

+ 测试1：用Sentinel控制台【菜单栏的 `流控规则 V1` 】推送流控规则，规则会存储到Nacos；

+ 测试2：直接在Nacos上修改流控规则，然后刷新Sentinel控制台，控制台上的显示也会被修改；

+ 测试3：重启Sentinel控制台，并重启微服务；刷新控制台，可以发现规则依然存在

### 7.万里长征才进行了第一步…

以上，其实只实现了流控规则的持久化。Sentinel有若干种规则，例如降级规则、系统规则、授权规则、热点规则等，都需要使用类似的方式，修改 `com.alibaba.csp.sentinel.dashboard.controller` 包中对应的Controller，才能实现持久化。

### 8.懒人包

笔者已经基于Sentinel Dashboard 1.6.2做了修改，为如下规则提供了持久化：

- 流控规则
- 降级规则
- 系统规则
- 授权规则
- 参数热点规则

GitHub地址：https://github.com/eacdy/Sentinel-Dashboard-Nacos ，使用1.6.2-NACOS分支即可。

使用说明：https://github.com/eacdy/Sentinel-Dashboard-Nacos/releases

修改的文件：

![](./img/109.png)

### 9.推模式优缺点分析

+ 优点
  + 规则持久化
  + 一致性好
  + 性能优秀

+ 改动多、并且麻烦

+ 引入额外的依赖（Nacos）

### 10.参考文档

```
https://github.com/alibaba/Sentinel/wiki/在生产环境中使用-Sentinel
```

## 如何在生产环境使用Sentinel

### 推拉模式持久化规则

+ 推模式更佳

### AHAS

+ 开通地址：https://ahas.console.aliyun.com/
+ 开通说明：https://help.aliyun.com/document_detail/90323.html

开通AHAS后，登录后选择应用流控然后选择应用接入，选择SDK应用接入，按照一步一步的来进行配置

![](./img/110.png)按照上图，先添加依赖，中间的添加埋点不需要我们去做，alibaba已经帮我们做了

```xml
<dependency>
   <groupId>com.alibaba.csp</groupId>
   <artifactId>spring-boot-starter-ahas-sentinel-client</artifactId>
   <version>1.5.0</version>
</dependency>
```

需要注意的是我们需要排除transport依赖，这个依赖是来连接我们自己本地的管理台

```xml
<dependency>
   <groupId>org.springframework.cloud</groupId>
   <artifactId>spring-cloud-starter-alibaba-sentinel</artifactId>
   <exclusions>
      <!--排除transport-->
      <exclusion>
         <groupId>org.alibaba.csp</groupId>
         <artifactId>sentinel-transport-simple-http</artifactId>
      </exclusion>
   </exclusions>
</dependency>
```

接下来将之前的配置注释掉，包括推模式和连接控制台的配置，加入新的配置

```yml
spring:
  datasource:
    url: jdbc:mysql://localhost:3306/content_center?useSSL=true
    hikari:
      username: root
      password: root
      # com.mysql.jdbc.Driver，如果connector的版本是5.x版本
      # 6.x或者以上的版本就要带上cj
      driver-class-name: com.mysql.jdbc.Driver
  cloud:
    nacos:
      discovery:
        # 指定nacos server地址，前面不要加http
        server-addr: localhost:8848
    # 添加sentinel的配置
    sentinel:
#      datasource:
#        # 名称随意
#        flow:
#          nacos:
#            server-addr: localhost:8848
#            dataId: ${spring.application.name}-flow-rules
#            groupId: SENTINEL_GROUP
#            # 规则类型，取值见：
#            # org.springframework.cloud.alibaba.sentinel.datasource.RuleType
#            rule-type: flow
#        degrade:
#          nacos:
#            server-addr: localhost:8848
#            dataId: ${spring.application.name}-degrade-rules
#            groupId: SENTINEL_GROUP
#            rule-type: degrade
#        system:
#          nacos:
#            server-addr: localhost:8848
#            dataId: ${spring.application.name}-system-rules
#            groupId: SENTINEL_GROUP
#            rule-type: system
#        authority:
#          nacos:
#            server-addr: localhost:8848
#            dataId: ${spring.application.name}-authority-rules
#            groupId: SENTINEL_GROUP
#            rule-type: authority
#        param-flow:
#          nacos:
#            server-addr: localhost:8848
#            dataId: ${spring.application.name}-param-flow-rules
#            groupId: SENTINEL_GROUP
#            rule-type: param-flow
      filter:
        # 关闭掉对SpringMVC端点的保护
        enabled: false
#      transport:
#        # sentinel控制台
#        dashboard: localhost:8080
```

加入启动参数

```yml
ahas.namespace: default
# 自定义应用名字
project.name: content-center
```

重启启动

**但是我这儿没有生效，不知道为什么？**

## 集群流控

将代码回到最初的样子：没有ahas，没有持久化，只有最初的控制台。

## 错误页的优化

打开对spring mvc端点的保护

```yml
spring:
    # 添加sentinel的配置
    sentinel:
      filter:
        # 关闭掉对SpringMVC端点的保护
        enabled: true
```

在之前我们配置好了流控规则，或者降级规则，在页面显示一样的错误信息

![](./img/70.png)

对此我们不能区分什么是流控，什么是降级，对此Sentinel提供了`UrlBlockHandler`来处里

```java
package com.itmuch.contentcenter.sentinelTest;

import com.alibaba.csp.sentinel.adapter.servlet.callback.UrlBlockHandler;
import com.alibaba.csp.sentinel.slots.block.BlockException;
import com.alibaba.csp.sentinel.slots.block.authority.AuthorityException;
import com.alibaba.csp.sentinel.slots.block.degrade.DegradeException;
import com.alibaba.csp.sentinel.slots.block.flow.FlowException;
import com.alibaba.csp.sentinel.slots.block.flow.param.ParamFlowException;
import com.alibaba.csp.sentinel.slots.system.SystemBlockException;
import com.fasterxml.jackson.databind.ObjectMapper;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;
import org.springframework.stereotype.Component;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;

/**
 * @author litian
 */
@Component
public class MyUrlBlockHandler implements UrlBlockHandler {

    @Override
    public void blocked(HttpServletRequest httpServletRequest,
                        HttpServletResponse httpServletResponse,
                        BlockException ex) throws IOException {
        ErrorMsg msg = null;
        if (ex instanceof FlowException) {
            msg = ErrorMsg.builder()
                    .status(101)
                    .msg("限流了")
                    .build();
        } else if (ex instanceof DegradeException) {
            msg = ErrorMsg.builder()
                    .status(102)
                    .msg("降级了")
                    .build();
        } else if (ex instanceof ParamFlowException) {
            msg = ErrorMsg.builder()
                    .status(103)
                    .msg("热点参数限流")
                    .build();
        } else if (ex instanceof SystemBlockException) {
            msg = ErrorMsg.builder()
                    .status(104)
                    .msg("系统负载不满足要求")
                    .build();
        } else if (ex instanceof AuthorityException) {
            msg = ErrorMsg.builder()
                    .status(105)
                    .msg("授权规则不通过")
                    .build();
        }
        httpServletResponse.setStatus(500);
        httpServletResponse.setCharacterEncoding("utf-8");
        httpServletResponse.setHeader("Content-Type", "application/json");
        httpServletResponse.setContentType("application/json;charset=utf-8");
        // Spring MVC自带的JSON操作工具，jackson
        new ObjectMapper().writeValue(httpServletResponse.getWriter(), msg);
    }



}

@Data
@AllArgsConstructor
@NoArgsConstructor
@Builder
class ErrorMsg {
    private Integer status;
    private String msg;
}
```

![](./img/111.png)

## 实现区分来源

在控制台上面的流控规则和授权规则都有来源的选项，但是我们到现在都没有用到，下面来玩玩：

```java
@Component
public class MyRequestOrigin implements RequestOriginParser {

    /**
     * 通过参数中的origin确认
     * @param request
     * @return 针对来源/授权规则中的应用
     */
    @Override
    public String parseOrigin(HttpServletRequest request) {
        // 从请求参数中获取名为origin的参数
        String origin = request.getParameter("origin");
        if (StringUtils.isBlank(origin)) {
            throw new IllegalArgumentException("origin must be specified");
        }
        return origin;
    }
}
```

上面代码中返回的就是来源，来我们做一下测试，因为我们加入了如果请求中没有origin这个参数就会报错，如下

![](./img/112.png)

然后我们在授权规则中加入来源

![](./img/113.png)

访问

 ![](./img/114.png)

流控规则针对来源同理

## Sentinel对RestFulUrl的支持

我们通过shres/1这个接口来做各种测试，但是当我们对其加上了相应的规则，再把接口换做shres/2会怎么样了？结果显而易见，是不支持的，sentinel不支持通配符，所以我们需要手动去实现：

```java
/**
 * @author litian
 */
@Component
public class MyUrlCleaner implements UrlCleaner {

    /**
     * 返回的String就是处理过后的url，比如shares/1， shares/2这种我们可以统一
     * 返回成shares/{number}这种形式
     * @param s
     * @return
     */
    @Override
    public String clean(String s) {

        String[] split = s.split("/");
        return Arrays.stream(split)
                .map(string -> NumberUtils.isNumber(string) ? "{number}" : string)
          			.reduce((a, b) -> a + "/" + b)
                .orElse("");
    }
}
```

这样页面的url就变成了如下：

![](./img/115.png)

## Alibaba Sentinel 配置项总结

http://www.imooc.com/article/289562