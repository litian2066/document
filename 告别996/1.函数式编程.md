# 告别996之函数编程

咱们通过实战案例来演示函数式编程的演变史

## 准备数据

定义一个商品信息

```java
package com.imooc.lambda.cart;

/**
 *  下单商品信息对象
 */
public class Sku {
    // 编号
    private Integer skuId;
    // 商品名称
    private String skuName;
    // 单价
    private Double skuPrice;
    // 购买个数
    private Integer totalNum;
    // 总价
    private Double totalPrice;
    // 商品类型
    private Enum skuCategory;
    // 构造方法
    public Sku(Integer skuId, String skuName, Double skuPrice, Integer totalNum, Double totalPrice, Enum skuCategory) {
        this.skuId = skuId;
        this.skuName = skuName;
        this.skuPrice = skuPrice;
        this.totalNum = totalNum;
        this.totalPrice = totalPrice;
        this.skuCategory = skuCategory;
    }
    // 生成get方法
    public Integer getSkuId() {
        return skuId;
    }

    public String getSkuName() {
        return skuName;
    }

    public Double getSkuPrice() {
        return skuPrice;
    }

    public Integer getTotalNum() {
        return totalNum;
    }

    public Double getTotalPrice() {
        return totalPrice;
    }

    public Enum getSkuCategory() {
        return skuCategory;
    }
}
```

枚举类

```java
// 商品类型枚举类
public enum SkuCategoryEnum {

    CLOTHING(10, "服装类"),
    ELECTRONICS(20, "电子类"),
    SPORTS(30, "运动类"),
    BOOKS(40, "书籍类");

    // 商品类型的编号
    private Integer code;
    // 商品类型的名称
    private String name;

    SkuCategoryEnum(Integer code, String name) {
        this.code = code;
        this.name = name;
    }
}
```

购物车服务类，初始化一些数据：

```java
// 购物车服务类
public class CartService {

    private static List<Sku> cartSkuList = new ArrayList<Sku>();
    // 初始化数据
    static {
        cartSkuList.add(new Sku(6543902, "无人机", 4999.00,
                1, 4999.00, SkuCategoryEnum.ELECTRONICS));

        cartSkuList.add(new Sku(642934, "VR一体机", 2299.00,
                1, 2299.00, SkuCategoryEnum.ELECTRONICS));

        cartSkuList.add(new Sku(645321, "纯色春衫", 409.00,
                1, 1227.00, SkuCategoryEnum.CLOTHING));

        cartSkuList.add(new Sku(645292, "牛仔裤", 528.00,
                1, 528.00, SkuCategoryEnum.CLOTHING));

        cartSkuList.add(new Sku(6541102, "跑步机", 2699.00,
                1, 2699.00, SkuCategoryEnum.SPORTS));

        cartSkuList.add(new Sku(6542202, "Java编程思想", 79.00,
                1, 79.00, SkuCategoryEnum.BOOKS));

        cartSkuList.add(new Sku(6543302, "Java核心技术", 149.00,
                1, 149.00, SkuCategoryEnum.BOOKS));
    }

    // 返回商品列表信息
    public static List<Sku> getCartSkuList() {
        return cartSkuList;
    }
}
```

## 硬编码逻辑

### 从商品中找出电子产品列表

```java
/**
 * 找出购物车中所有的电子产品
 * @Version 1.0
 * @param cartSkuList
 * @return
 */
public static List<Sku> filterElectronics(List<Sku> cartSkuList) {
    List<Sku> result = new ArrayList<Sku>();
    for (int i = 0; i < cartSkuList.size(); i++) {
        Sku sku = cartSkuList.get(i);
        if (SkuCategoryEnum.ELECTRONICS.equals(sku.getSkuCategory())) {
            result.add(sku);
        }
    }
    return result;
}
```

测试，这儿引入alibaba的fastjon方便查看结果：

```xml
<dependency>
  <groupId>junit</groupId>
  <artifactId>junit</artifactId>
  <version>4.12</version>
  <scope>test</scope>
</dependency>

<dependency>
  <groupId>com.alibaba</groupId>
  <artifactId>fastjson</artifactId>
  <version>1.2.58</version>
</dependency>
```



```java
@Test
public void filterElectronicsTest() {
    List<Sku> skuList = CartService.getCartSkuList();
    List<Sku> result = CartService.filterElectronics(skuList);
    // true : 格式化json
    System.out.println(JSON.toJSONString(result, true));
}
```



````java
[
	{
		"skuCategory":"ELECTRONICS",
		"skuId":6543902,
		"skuName":"无人机",
		"skuPrice":4999.0,
		"totalNum":1,
		"totalPrice":4999.0
	},
	{
		"skuCategory":"ELECTRONICS",
		"skuId":642934,
		"skuName":"VR一体机",
		"skuPrice":2299.0,
		"totalNum":1,
		"totalPrice":2299.0
	}
]
````

可见结果正确

### 单一维度条件参数化

比如新增一个需求：根据商品分类找出对应的商品列表

```java
/**
 * 根据商品分类找出对应的商品列表
 * @Version 2.0
 * @param cartSkuList
 * @param skuCategoryEnum
 * @return
 */
public static List<Sku> filterElectronicsByCategory(List<Sku> cartSkuList,
                                                    SkuCategoryEnum skuCategoryEnum) {
    List<Sku> result = new ArrayList<Sku>();
    for (int i = 0; i < cartSkuList.size(); i++) {
        Sku sku = cartSkuList.get(i);
        if (skuCategoryEnum.equals(sku.getSkuCategory())) {
            result.add(sku);
        }
    }
    return result;
}
```

## 多维度过滤

比如再来一需求：通过商品类型或者总价来过滤商品信息

```java
/**
 * 通过商品类型或者商品总价来过滤商品
 * @Version 3.0
 * @param cartSkuList
 * @param skuCategoryEnum
 * @param totalPrice
 * @param categoryOrPrice
 * @return
 */
public static List<Sku> filterSku(List<Sku> cartSkuList,
                                 SkuCategoryEnum skuCategoryEnum, Double totalPrice,
                                  Boolean categoryOrPrice) {
    List<Sku> result = new ArrayList<Sku>();
    for (int i = 0; i < cartSkuList.size(); i++) {
        Sku sku = cartSkuList.get(i);
        if (categoryOrPrice && skuCategoryEnum.equals(sku.getSkuCategory())) {
            if (skuCategoryEnum.equals(sku.getSkuCategory())) {
                result.add(sku);
            }
        } else if (!categoryOrPrice && sku.getTotalPrice() > totalPrice) {
            result.add(sku);
        }
    }
    return result;
}
```

## 策略

通过上面的需求，我们发现每一次迭代都会新增冗余的代码，如果有更多的需求了，通过以上的需求，我们可以发现，每一个需求都是比较，也就是返回true 或者 false，那么我们可以把选择的标准抽象出来，此时我们可以使用策略模式。

新增策略接口

```java
/**
 * Sku谓词接口
 */
public interface SkuPredicate {

    /**
     * 选择判断标准
     * @param sku
     * @return
     */
    boolean test(Sku sku);
}
```

新需求方法：

```java
/**
 * 根据sku不同的判断标准侧率来进行过滤
 * version 4.0
 * @param cartSkuList
 * @param skuPredicate
 * @return
 */
public static List<Sku> filterSkus(List<Sku> cartSkuList, SkuPredicate skuPredicate) {
    List<Sku> result = new ArrayList<Sku>();
    for (int i = 0; i < cartSkuList.size(); i++) {
        Sku sku = cartSkuList.get(i);
        if (skuPredicate.test(sku)) {
            result.add(sku);
        }
    }
    return result;
}
```

新增实现类，实现策略：

```java
/**
 * 对sku商品的图书类进行过滤
 */
public class SkuBooksCategoryPredicate implements SkuPredicate {

    public boolean test(Sku sku) {
        return SkuCategoryEnum.BOOKS.equals(sku.getSkuCategory());
    }
}
```

测试：

```java
@Test
public void filterSkuPredicateTest() {
    List<Sku> skuList = CartService.getCartSkuList();
    SkuPredicate skuPredicate = new SkuBooksCategoryPredicate();
    List<Sku> result = CartService.filterSkus(skuList, skuPredicate);
    // true : 格式化json
    System.out.println(JSON.toJSONString(result, true));
}
```

```java
[
	{
		"skuCategory":"BOOKS",
		"skuId":6542202,
		"skuName":"Java编程思想",
		"skuPrice":79.0,
		"totalNum":1,
		"totalPrice":79.0
	},
	{
		"skuCategory":"BOOKS",
		"skuId":6543302,
		"skuName":"Java核心技术",
		"skuPrice":149.0,
		"totalNum":1,
		"totalPrice":149.0
	}
]
```

成功将书籍信息打印出来，可见这种方式比上一种更好，更通用，但是我们可不可以再优化呢

## 匿名函数

有过java基础都知道，接口可以通过匿名函数来实现：

```java
@Test
public void filterSkuPredicateTest2() {
    List<Sku> skuList = CartService.getCartSkuList();
    List<Sku> result = CartService.filterSkus(skuList, new SkuPredicate() {
        public boolean test(Sku sku) {
            return SkuCategoryEnum.BOOKS.equals(sku.getSkuCategory());
        }
    });
    System.out.println(JSON.toJSONString(result, true));
}
```

这种方式照样成功。那么还有没有更优化的方法，对于jdk1.8之前来说是没有的，但是在jdk1.8之后有。

## Lambda表达式

```java
@Test
public void filterSkuPredicateTest3() {
    List<Sku> skuList = CartService.getCartSkuList();
    List<Sku> result = CartService.filterSkus(skuList,
            (Sku sku) ->  SkuCategoryEnum.BOOKS.equals(sku.getSkuCategory()));
    System.out.println(JSON.toJSONString(result, true));
}
```

## 函数式接口

Scala和Kotnlin提供了多范式的编程体验，java8也开启了探索，所以会有lambda表达式以及stream，给我们提供了更便捷的体验。

怎么能使用lambda表达式呢？只有接口中只有一个方法，而这样的接口我们称为函数式接口，所以有如下定义：

+ 接口中只有一个方法
+ Java8的函数式注解：`@FunctionalInterface`

### 小案例

自定义函数式接口，实现读取本地文件后自定义处理逻辑的功能。

```java
package com.imooc.lambda.cart;

@FunctionalInterface
public interface FileConsumer {

    /**
     * 函数式接口抽象方法
     * @param fileContent 文件内容字符串
     */
    void fileHandler(String fileContent);
}
```

```java
package com.imooc.lambda.cart;

import java.io.BufferedReader;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.InputStreamReader;

public class FileService {

    /**
     * 从url获取本地文件内容，调用函数式接口处理
     * @param url
     * @param fileConsumer
     */
    public void fileHandle(String url, FileConsumer fileConsumer) throws Exception {
        BufferedReader bufferedReader = new BufferedReader
                (new InputStreamReader(new FileInputStream(url)));

        String line;
        StringBuilder stringBuilder = new StringBuilder();

        while ((line = bufferedReader.readLine()) != null) {
            stringBuilder.append(line + "\n");
        }
        // 调用函数式接口方法，将文件内容传递给lambda表达式，实现业务逻辑
        fileConsumer.fileHandler(stringBuilder.toString());
    }
}
```

测试

```java
@Test
public void fileServiceTest() throws Exception {

    FileService fileService = new FileService();

    fileService.fileHandle("/Users/litian/Documents/Work-Code/work" +
                    "/996/src/main/java/com/imooc/lambda/cart/FileService.java",
            fileContent -> {
        System.out.println(fileContent);
    });
}
```

````
package com.imooc.lambda.cart;

import java.io.BufferedReader;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.InputStreamReader;

public class FileService {

    /**
     * 从url获取本地文件内容，调用函数式接口处理
     * @param url
     * @param fileConsumer
     */
    public void fileHandle(String url, FileConsumer fileConsumer) throws Exception {
        BufferedReader bufferedReader = new BufferedReader
                (new InputStreamReader(new FileInputStream(url)));

        String line;
        StringBuilder stringBuilder = new StringBuilder();

        while ((line = bufferedReader.readLine()) != null) {
            stringBuilder.append(line + "\n");
        }
        // 调用函数式接口方法，将文件内容传递给lambda表达式，实现业务逻辑
        fileConsumer.fileHandler(stringBuilder.toString());
    }
}
````

测试成功，将类的信息打印出来了，这儿我们只是简单的做了一个打印，也可以做其他操作。

## 常用函数式接口

其实好多类型的函数式接口JDK8已经给我们提供了，比如Customer、Predicate之类的：

| 接口              | 参数   | 返回类型 | 描述                                                         |
| ----------------- | ------ | -------- | ------------------------------------------------------------ |
| Predicate<T>      | T      | Boolean  | 用于判别一个对象，比如求一个人是否是男性。                   |
| Consumer<T>       | T      | Void     | 用于接收一个对象进行处理但是没有返回，比如接收一个人并打印他的名字 |
| Function<T, R>    | T      | R        | 转换一个对象为不同类型的对象                                 |
| Supplier<T>       | Node   | T        | 提供一个对象                                                 |
| UnaryOperator<T>  | T      | T        | 接收对象并返回同类型的对象                                   |
| BinaryOperator<T> | (T, T) | T        | 接收两个同类型的对象，并返回一个原类型的对象                 |

可以看出原本我们自己定义的接口根本没有必要，我们可以使用jdk8提供的这些个泛化的函数式接口来进行操作。

除此之外，jdk8还提供了一些个基础类型的函数式接口，比如：`DoulbePredicate`

```java
@FunctionalInterface
public interface DoublePredicate {

    boolean test(double value);

    default DoublePredicate and(DoublePredicate other) {
        Objects.requireNonNull(other);
        return (value) -> test(value) && other.test(value);
    }

    default DoublePredicate negate() {
        return (value) -> !test(value);
    }

  
    default DoublePredicate or(DoublePredicate other) {
        Objects.requireNonNull(other);
        return (value) -> test(value) || other.test(value);
    }
}
```

这样可以避免装箱拆箱，性能有所提升。

## 方法引用

举例一段代码：

````java
public static List<Sku> filterSkus3(List<Sku> cartSkuList) {
  List<Sku> result = new ArrayList<Sku>();
  Optional.ofNullable(cartSkuList)
    .map(List::stream)
    .orElseGet(Stream::empty)
    .sorted(Comparator.comparing(Sku::getSkuPrice))
    .forEach(result::add);
  return result;
}
````

简单的解释就是将非空的list转换成流，然后排序，放入另一个list里面。

**这个双冒号是个什么鬼？**

其实就是方法引用

### 定义

​	调用特定犯法的Lambda表达式的一种快捷写法，可以让你重复使用现有方法定义，并像Lambda表达式一样传递他们。

### 指向静态方法的方法引用

`````java
public void test() {
  Consumer<String> consumer = (String number) -> Integer.parseInt(number);
  Consumer<String> consumer2 = Integer::parseInt;
  
}
`````

### 指向任意类型实例方法的方法引用

````java
public void test2() {
  Consumer<String> consumer = (String str) -> str.length();
  
  Consumer<String> consumer2 = String::length;
}
````

### 指向现有对象的实例方法的方法引用：

````java
public void test3() {
  StringBuilder stringBuilder = new StringBuilder();
  Consumer<String> consumer = (String str) -> stringBuilder.append(str);
  
  Consumer<String> consumer2 = stringBuilder::append;
}
````

