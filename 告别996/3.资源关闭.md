# 告别996之资源关闭

本节旨在使用jdk提供的高效的语法糖，优化地关闭资源。

## 风骚码农和一般码农的区别

在之前学习lambda表达式的时候有一段处理文件的代码：

```java
/**
  * 从url获取本地文件内容，调用函数式接口处理
  * @param url
  * @param fileConsumer
*/
public void fileHandle(String url, FileConsumer fileConsumer) throws Exception {
  BufferedReader bufferedReader = new BufferedReader
  (new InputStreamReader(new FileInputStream(url)));

  String line;
  StringBuilder stringBuilder = new StringBuilder();

  while ((line = bufferedReader.readLine()) != null) {
  	stringBuilder.append(line + "\n");
  }
	// 调用函数式接口方法，将文件内容传递给lambda表达式，实现业务逻辑
	fileConsumer.fileHandler(stringBuilder.toString());
}
```

这段代码测试环境是没有问题的，但是因为没有关闭资源所以在生产环境可能存在严重的隐患，所以我们需要加入资源关闭的操作：

```java
public void fileHandle(String url, FileConsumer fileConsumer) {
    FileInputStream fileInputStream = null;
    BufferedReader bufferedReader = null;
    InputStreamReader inputStreamReader = null;
    try {
        fileInputStream = new FileInputStream(url);
        inputStreamReader = new InputStreamReader(fileInputStream);
        bufferedReader = new BufferedReader(inputStreamReader);

        String line;
        StringBuilder stringBuilder = new StringBuilder();
        while ((line = bufferedReader.readLine()) != null) {
            stringBuilder.append(line + "\n");
        }
        // 调用函数式接口方法，将文件内容传递给lambda表达式，实现业务逻辑
        fileConsumer.fileHandler(stringBuilder.toString());

    } catch (FileNotFoundException e) {
        e.printStackTrace();
    } catch (IOException e) {
        e.printStackTrace();
    } finally {
        // 关闭流资源
        if (bufferedReader != null) {
            try {
                bufferedReader.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
        if (inputStreamReader != null) {
            try {
                inputStreamReader.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
        if (fileInputStream != null) {
            try {
                fileInputStream.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }
}
```

可见代码是多么的冗长，来看看改进后的代码：

```java
public void fileHandleVo(String url, FileConsumer fileConsumer) {
    try (
         FileInputStream fileInputStream = new FileInputStream(url);
         InputStreamReader inputStreamReader = new InputStreamReader(fileInputStream);
         BufferedReader bufferedReader = new BufferedReader(inputStreamReader);
         )
    {
        String line;
        StringBuilder stringBuilder = new StringBuilder();
        while ((line = bufferedReader.readLine()) != null) {
            stringBuilder.append(line + "\n");
        }
        // 调用函数式接口方法，将文件内容传递给lambda表达式，实现业务逻辑
        fileConsumer.fileHandler(stringBuilder.toString());

    } catch (FileNotFoundException e) {
        e.printStackTrace();
    } catch (IOException e) {
        e.printStackTrace();
    }
}
```

可见代码精简了很多行，使用新版的关闭流方式来处理资源关闭可以大大减少代码。

## 垃圾回收(GC)的特点

说起为什么要资源关闭，就不得不要谈起GC。

+ 垃圾回收机制只负责回收堆内存资源，不会回收任何**物理资源**
+ 程序无法**精确控制**垃圾回收动作的具体发生时间
+ 在垃圾回收之前，总会调用它的**finalize方法**

## 常见需手动释放的物理资源

+ 文件/流资源
+ 套接字资源
+ 数据库连接资源

## 传统流资源关闭

这儿模拟一个文件拷贝的操作。

### jdk1.7版关闭资源

```java
@Test
public void copyFile() {
    /**
     * 1. 创建输入/输出流
     * 2. 执行文件拷贝，读取文件内容，写入到另一个文件
     * 3. 关闭文件流资源
     */

    // 定义输入路径和输出路径
    String orginalUrl = "lib/FileCopyTest.java";
    String targetUrl = "targetTest/target.txt";

    FileInputStream originalFileInputStream = null;
    FileOutputStream targetFileInputStream = null;

    try {
        originalFileInputStream = new FileInputStream(orginalUrl);
        targetFileInputStream = new FileOutputStream(targetUrl);

        // 读取的字节信息
        int content;
        // 迭代，读取，写入字节
        while ((content = originalFileInputStream.read()) != -1) {
            targetFileInputStream.write(content);
        }
    } catch (FileNotFoundException e) {
        e.printStackTrace();
    } catch (IOException e) {
        e.printStackTrace();
    } finally {
        // 先打开，后关闭
        if (targetFileInputStream != null) {
            try {
                targetFileInputStream.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
        if (originalFileInputStream != null) {
            try {
                originalFileInputStream.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }

}
```

### TWR方式资源关闭

```java
/**
 * jdk1.7之后关闭资源的方式
 */
@Test
public void copyFileVo() {
    // 定义输入路径和输出路径
    String orginalUrl = "lib/FileCopyTest.java";
    String targetUrl = "targetTest/target1.txt";
    try(
        FileInputStream originalFileInputStream = new FileInputStream(orginalUrl);
        FileOutputStream targetFileInputStream = new FileOutputStream(targetUrl);
    ) {
        // 读取的字节信息
        int content;
        // 迭代，读取，写入字节
        while ((content = originalFileInputStream.read()) != -1) {
            targetFileInputStream.write(content);
        }
    } catch (FileNotFoundException e) {
        e.printStackTrace();
    } catch (IOException e) {
        e.printStackTrace();
    }
}
```

## try-with-resource简介

+ Java7引入新特性
+ 优雅关闭资源
+ 一种Java语法糖

## try-with-resource源码分析

查看编译后源码，分析内部原理

在idea的target目录下找到我们编写过的代码，可以看到如下：

```java
@Test
public void copyFileVo() {
    String orginalUrl = "lib/FileCopyTest.java";
    String targetUrl = "targetTest/target1.txt";

    try {
        FileInputStream originalFileInputStream = new FileInputStream(orginalUrl);
        Throwable var4 = null;

        try {
            FileOutputStream targetFileInputStream = new FileOutputStream(targetUrl);
            Throwable var6 = null;

            try {
                int content;
                try {
                    while((content = originalFileInputStream.read()) != -1) {
                        targetFileInputStream.write(content);
                    }
                } catch (Throwable var33) {
                    var6 = var33;
                    throw var33;
                }
            } finally {
                if (targetFileInputStream != null) {
                    if (var6 != null) {
                        try {
                            targetFileInputStream.close();
                        } catch (Throwable var32) {
                            var6.addSuppressed(var32);
                        }
                    } else {
                        targetFileInputStream.close();
                    }
                }

            }
        } catch (Throwable var35) {
            var4 = var35;
            throw var35;
        } finally {
            if (originalFileInputStream != null) {
                if (var4 != null) {
                    try {
                        originalFileInputStream.close();
                    } catch (Throwable var31) {
                        var4.addSuppressed(var31);
                    }
                } else {
                    originalFileInputStream.close();
                }
            }

        }
    } catch (FileNotFoundException var37) {
        var37.printStackTrace();
    } catch (IOException var38) {
        var38.printStackTrace();
    }

}
```

可以看出就算使用语法糖，编译后还是要在finally中关闭资源（java7提供的异常追加的方式），只是**简化了代码，并没有优化**

## try-with-resource使用

+ 多资源自动关闭

+ 实现AutoCloseable接口

+ 避免异常屏蔽

  Java7采用异常追加的方式来处理

## 资源关闭的特殊情况

+ 资源对象被return的情况下，由调用方关闭

+ ByteArrayInputStream等不需要检查关闭的资源对象

  它们的源码显示close方法时空的方法体，也就是说不需要关闭

+ 使用socket获取的InputStream和OutputStream对象不需要关闭

  应该使用shutdownInput或者shutdownIOutput关闭对应的输入流或者输出流