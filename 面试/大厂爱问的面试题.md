# 基础

## 1. String为什么要设计成Final

### 1. 什么是不可变？

String不可变很简单，如下图，给一个已有字符串"abcd"第二次赋值成"abcedl"，不是在原内存地址上修改数据，而是重新指向一个新对象，新地址。

![](./img/1.png)

### 2. String为什么不可变？

首先String类是用final关键字修饰，这说明String不可继承。再看下面，String类的主力成员字段value是个char[ ]数组，而且是用**final**修饰的。final修饰的字段创建以后就不可改变。

有的人以为故事就这样完了，其实没有。因为虽然value是不可变，也只是value这个引用地址不可变。挡不住**Array数组是可变的**事实。Array的数据结构看下图。

![](./img/2.png)



也就是说Array变量只是栈stack上的一个引用，数组的本体结构在heap堆。String类里的value用final修饰，只是说stack里的这个叫value的引用地址不可变。没有说堆里array本身数据不可变。看下面这个例子：

```java
final int[] value = {1,2,3}
int[] another = { 4,5,6};
value = another;    //编译器报错，final不可变
```

value用final修饰，编译器不允许我把value指向堆区另一个地址。但如果我直接对数组元素动手，分分钟搞定。

```java
final int[] value={1,2,3};
value[2]=100;  //这时候数组里已经是{1,2,100}
```

或者更粗暴的反射直接改，也是可以的。

```java
final int[] array={1,2,3};
Array.set(array,2,100); //数组也被改成{1,2,100}
```

所以String是不可变，***\*关键是\****因为SUN公司的工程师，在后面所有String的方法里很小心的没有去动Array里的元素，没有暴露内部成员字段。

`private final char value[]`这一句里，private的私有访问权限的作用都比final大。而且设计师还很小心地把整个String设成final禁止继承，避免被其他人继承后破坏。所以**String是不可变的关键都在底层的实现，而不是一个final**。考验的是工程师构造数据类型，封装数据的功力。

### 3. 不可变有什么好处？

这个最简单的原因，就是为了**安全**。

#### 示例1

````java
public class 为什么String要设计成不可变类你 {
 
	public static void main(String[] args) {
 
		String a, b, c;
		a = "test";
		b = a;
		c = b;
		String processA = processA(a);
		String processB = processB(b);
		String processC = processC(c);
		System.out.println(processA);
		System.out.println(processB);
		System.out.println(processC);
	}
	
	static String processA(String str){
		return str + "A";
	}
	
	static String processB(String str){
		return str + "B";
	}
	
	static String processC(String str){
		return str + "C";
	}
 
}
//OUTPUT
// testA
//testB
//testC
````

当String支持非可变性的时候，它们的值很好确定，不管调用哪个方法，都互不影响。

如果String是可变的，就可能如下例，我们使用StringBuffer来模拟String是可变的

````java
package _12_01字符串;
 
public class 为什么String要设计成不可变类2 {
 
	public static void main(String[] args) {
 
		StringBuffer a, b, c;
		a = new StringBuffer("test");
		b = a;
		c = b;
		String processA = processA(a);
		String processB = processB(b);
		String processC = processC(c);
		System.out.println(processA);
		System.out.println(processB);
		System.out.println(processC);
	}
	
	static String processA(StringBuffer str){
		return str.append("A").toString();
	}
	
	static String processB(StringBuffer str){
		return str.append("B").toString();
	}
	
	static String processC(StringBuffer str){
		return str.append("C").toString();
	}
 
}
//OUTPUT
// testA
//testAB
//testABC
````

#### 示例2

再看下面这个**HashSet**用StringBuilder做元素的场景，问题就更严重了，而且更隐蔽。

````java
class Test{
    public static void main(String[] args){
        HashSet<StringBuilder> hs=new HashSet<StringBuilder>();
        StringBuilder sb1=new StringBuilder("aaa");
        StringBuilder sb2=new StringBuilder("aaabbb");
        hs.add(sb1);
        hs.add(sb2);    //这时候HashSet里是{"aaa","aaabbb"}
 
        StringBuilder sb3=sb1;
        sb3.append("bbb");  //这时候HashSet里是{"aaabbb","aaabbb"}
        System.out.println(hs);
    }
}
//Output:
//[aaabbb, aaabbb]
````

StringBuilder型变量sb1和sb2分别指向了堆内的字面量"aaa"和"aaabbb"。把他们都插入一个HashSet。到这一步没问题。但如果后面我把变量sb3也指向sb1的地址，再改变sb3的值，因为StringBuilder没有不可变性的保护，sb3直接在原先"aaa"的地址上改。导致sb1的值也变了。这时候，HashSet上就出现了两个相等的键值"aaabbb"。**破坏了HashSet键值的唯一性，所以千万不要用可变类型做HashMap和HashSet键值。**

### 4. 不可变性支持线程安全

还有一个大家都知道，就是在并发场景下，多个线程同时读一个资源，是不会引发竟态条件的。只有对资源做写操作才有危险。不可变对象不能被写，所以线程安全。

### 5. 不可变性支持字符串常量池

**最后别忘了String字符串常量池的属性。像下面这样字符串one和two都用字面量something赋值。它们其实都指向同一个内存地址。**

````java
String one = "someString";
String two = "someString";
````

![](./img/3.png)

这样在大量使用字符串的情况下，可以节省内存空间，提高效率。但之所以能实现这个特性，String的不可变性是最基本的一个必要条件。要是内存里字符串内容能改来改去，这么做就完全没有意义了。

## 2. `String StringBuffer`和`StringBulider`的区别

`String`的值是不可变的，这就导致每次对String的操作都会生成**新的String对象**，这样不仅效率低下，而且大量浪费有限的内存空间。和`String`类不同的是，`StringBuffer`和`StringBuilder`类的对象能够被多次的修改，它们均是可变的字符串，并且**不产生新的未使用对象**。

**它们底层也是`char[] value;`数组形式，在操作一定大小的字符串，它们的性能是一样的，超过这个大小就是`StringBuilder`效率高点，因为它是线程不安全的。**

## 3. 你能给我写一个`final`对象吗

## 4. 重写hashcode()方法

### 1. **equals方法**

Object类中默认的实现方式是  :  `return this == obj`。那就是说，只有this和obj引用同一个对象，才会返回true。

而我们往往需要用equals来判断2个对象是否等价，而非验证他们的唯一性。这样我们在实现自己的类时，就要重写equals。因为我们需要利用对象里面的值来判断是否相等，则重载equal方法。

### 2. 为什么要重写hashCode()方法？

一般的地方不需要重载hashCode，只有当类需要放在`HashTable`、`HashMap`、`HashSet`等等`hash`结构的集合时才会重载hashCode，那么为什么要重载hashCode呢？

如果你重写了equals，比如说是基于对象的内容实现的，而保留hashCode的实现不变，那么很可能某两个对象明明是**“相等”**，而hashCode却不一样。

**这样，当你用其中的一个作为键保存到hashMap、hashTable或hashSet中，再以“相等的”找另一个作为键值去查找他们的时候，则根本找不到。**

### 3. 为什么equals()相等，hashCode就一定要相等，而hashCode相等，却不要求equals相等?

1. 因为是按照hashCode来访问小内存块，所以hashCode必须相等。
2. HashMap获取一个对象是比较key的hashCode相等和equal为true。

之所以hashCode相等，却可以equal不等，就比如ObjectA和ObjectB他们都有属性name，那么hashCode都以name计算，所以hashCode一样，但是两个对象属于不同类型，所以equal为false。

### 4. 为什么需要hashCode?

1. 通过hashCode可以很快的查到小内存块。 
2. 通过hashCode比较比equal方法快，当get时先比较hashCode，如果hashCode不同，直接返回false。

## 5. Java序列化

