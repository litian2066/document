## 1.synchronized和lock的区别

1. 首先synchronized是java内置关键字，在jvm层面，Lock是个java类；
2. synchronized无法判断是否获取锁的状态，Lock可以判断是否获取到锁；
3. synchronized会自动释放锁(a 线程执行完同步代码会释放锁 ；b 线程执行过程中发生异常会释放锁)，Lock需在finally中手工释放锁（unlock()方法释放锁），否则容易造成线程死锁；
4. 用synchronized关键字的两个线程1和线程2，如果当前线程1获得锁，线程2线程等待。如果线程1阻塞，线程2则会一直等待下去，而Lock锁就不一定会等待下去，如果尝试获取不到锁，线程可以不用一直等待就结束了；
5. synchronized的锁可重入、不可中断、非公平，而Lock锁可重入、可判断、可公平（两者皆可）。
6. Lock锁适合大量同步的代码的同步问题，synchronized锁适合代码少量的同步问题。

## 2.怎么实现线程安全

synchronized和lock

## **3.线程间通信的方式**

1. #### 使用 *volatile* 关键字

2. #### 使用Object类的wait() 和 notify() 方法

3. #### 使用JUC工具类 CountDownLatch

4. #### 使用 ReentrantLock 结合 Condition

5. #### 基本LockSupport实现线程间的阻塞和唤醒

## 4.redis哨兵模式原理

每个哨兵节点维护了3个定时任务。获取最新的主从结构，每两秒通过发布订阅功能获取其他哨兵节点的信息（判断对主节点的看法），每1秒通过向其他节点发送ping命令进行心跳检测，判断是否下线（monitor）。

通过心跳检测判断主节点是否超时，如果有就进行主观下线，然后通过询问其他节点，主观下线节点数达到配置，就对主节点进行客观下线，然后进行故障转移操作：

1. 挑选新的主节点
2. 更新主从状态：通过salve of xx命令让其他节点成为这个节点的从节点
3. 对已经下线的节点关注，其上线，再让其成为现任主节点的从节点

## 5.RabbitMQ我应该记住的东西

1. 消费者默认手动确认，自动确认话消息会消失，如果出现了故障不会回滚

2. 发送方确认模式（确认消息到达了交换机）和失败回调（在**消息从交换机到达队列**的时候，如果失败了会调用一个失败回调方法）（都在发送方配置，rabbitTempalte回调，发送时回调）

3. 发送方确认模式一般也会和失败回调一起使用 这样 就能确保消息100%投递了，也可以使用备用交换机，只要备用交换机有绑定队列就能保证消息投递成功。

4. 消息预取

   以前是rabbitmq一股脑吧所有消息都均发给所有的消费者（不管你受不受得了） 而现在是在我消费者消费之前 先告诉rabbitmq **我一次能消费多少数据等我消费完了之后告诉rabbitmq**，rabbitmq再给我发送数据（个数500性能比较好，个数越少可靠性高，但是性能差）。

5. **死信交换机**

6. 防止消费者重复消费的方式是手动设定一个状态变量进行判断

7. 普通集群下，节点之间会有对方的队列信息（配置信息），通过配置信息进行队列的定位

8. 集群节点分内存和磁盘节点，一定要有一个磁盘节点，为了恢复数据

9. 简单来说，镜像队列机制就是将队列在三个节点之间设置主从关系，消息会在三个节点之间进行自动同步，且如果其中一个节点不可用，并不会导致消息丢失或服务不可用的情况，提升MQ集群的整体高可用性。

6. 

## 6.oracle同义词

## 7.101到200的素数

````java

/**
 * 输出100-200之间的质数
 * 
 * @author 46512
 */
public class PrimeDemo {
    public static void main(String[] args) {
        // 外层循环，遍历100-200之间的数
        for (int i = 100; i <= 200; i++) {
            // 对100-200之间的每一个数进行遍历
            // 质数，正整数，除了1和它本身之外，不能被任何中间数整除
            boolean flag = true; // false 不是 质数，true是质数
            for (int j = 2; j < i; j++) {
                if (i % j == 0) {
                    // 不是质数
                    flag = false;
                    break;
                }
            }
            // 不管是不是质数，都会执行到这里
            // 可以根据flag这个标志来判断是否是质数
            /*if (flag) {
                System.out.println(i + "是质数");
            }*/

            //使用continue
            if(!flag){
                continue;
            }
            System.out.println(i + "是质数");
        }
    }
}
````



## 8.有序的set

TreeSet 就是有序的！ String 默认的Compare 是根据字母排序的，如果是自己的对象，需要实现对应的Comparable接口

```java
public TreeSet() {
  this(new TreeMap<E,Object>());
}

public TreeSet(Comparator<? super E> comparator) {
  this(new TreeMap<>(comparator));
}
```

**LinkedHashSet 有序、线程不安全**

## 9.AOP通知的顺序

1. before

   method

2. around

3. after

4. After return

## 10.Mybatis一级和二级缓存

Mybatis对缓存提供支持，但是在没有配置的默认情况下，它只开启一级缓存，一级缓存只是相对于同一个SqlSession而言。所以在参数和SQL完全一样的情况下，我们使用同一个SqlSession对象调用一个Mapper方法，往往只执行一次SQL，因为使用SelSession第一次查询后，MyBatis会将其放在缓存中，以后再查询的时候，如果没有声明需要刷新，并且缓存没有超时的情况下，SqlSession都会取出当前缓存的数据，而不会再次发送SQL到数据库。

**1、一级缓存的生命周期有多长？**

　　a、MyBatis在开启一个数据库会话时，会 创建一个新的SqlSession对象，SqlSession对象中会有一个新的Executor对象。Executor对象中持有一个新的PerpetualCache对象；当会话结束时，SqlSession对象及其内部的Executor对象还有PerpetualCache对象也一并释放掉。

　　b、如果SqlSession调用了close()方法，会释放掉一级缓存PerpetualCache对象，一级缓存将不可用。

　　c、如果SqlSession调用了clearCache()，会清空PerpetualCache对象中的数据，但是该对象仍可使用。

　　d、SqlSession中执行了任何一个update操作(update()、delete()、insert()) ，都会清空PerpetualCache对象的数据，但是该对象可以继续使用

**2、怎么判断某两次查询是完全相同的查询？**



　　mybatis认为，对于两次查询，如果以下条件都完全一样，那么就认为它们是完全相同的两次查询。

　　2.1 传入的statementId

　　2.2 查询时要求的结果集中的结果范围

　　2.3. 这次查询所产生的最终要传递给JDBC java.sql.Preparedstatement的Sql语句字符串（boundSql.getSql() ）

　　2.4 传递给java.sql.Statement要设置的参数值

**二级缓存：**

**总结：mybatis的的一级缓存是SqlSession级别的缓存，一级缓存缓存的是对象，当SqlSession提交、关闭以及其他的更新数据库的操作发生后，一级缓存就会清空。二级缓存是SqlSessionFactory级别的缓存，同一个SqlSessionFactory产生的SqlSession都共享一个****二级缓存，二级缓存中存储的是数据，当命中二级缓存时，通过存储的数据构造对象返回。查询数据的时候，查询的流程是二级缓存>一级缓存>数据库*****。***

## 11.double计算精度损失，怎么解决，bigDicemal构造



## 12.MySqllimit

## 13.方法区 详细了解

## 14.MySQL怎么优化的

