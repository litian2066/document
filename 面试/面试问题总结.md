1. **synchronized和lock的区别**

   1. 首先synchronized是java内置关键字，在jvm层面，Lock是个java类；
   2. synchronized无法判断是否获取锁的状态，Lock可以判断是否获取到锁；
   3. synchronized会自动释放锁(a 线程执行完同步代码会释放锁 ；b 线程执行过程中发生异常会释放锁)，Lock需在finally中手工释放锁（unlock()方法释放锁），否则容易造成线程死锁；
   4. 用synchronized关键字的两个线程1和线程2，如果当前线程1获得锁，线程2线程等待。如果线程1阻塞，线程2则会一直等待下去，而Lock锁就不一定会等待下去，如果尝试获取不到锁，线程可以不用一直等待就结束了；
   5. synchronized的锁可重入、不可中断、非公平，而Lock锁可重入、可判断、可公平（两者皆可）。
   6. Lock锁适合大量同步的代码的同步问题，synchronized锁适合代码少量的同步问题。

2. **怎么实现线程安全**

   synchronized和lock

3. **线程间通信的方式**

   1. #### 使用 *volatile* 关键字

   2. #### 使用Object类的wait() 和 notify() 方法

   3. #### 使用JUC工具类 CountDownLatch

   4. #### 使用 ReentrantLock 结合 Condition

   5. #### 基本LockSupport实现线程间的阻塞和唤醒

4. **redis哨兵模式原理**

   每个哨兵节点维护了3个定时任务。获取最新的主从结构，每两秒通过发布订阅功能获取其他哨兵节点的信息（判断对主节点的看法），每1秒通过向其他节点发送ping命令进行心跳检测，判断是否下线（monitor）。

   通过心跳检测判断主节点是否超时，如果有就进行主观下线，然后通过询问其他节点，主观下线节点数达到配置，就对主节点进行客观下线，然后进行故障转移操作：

   1. 挑选新的主节点
   2. 更新主从状态：通过salve of xx命令让其他节点成为这个节点的从节点
   3. 对已经下线的节点关注，其上线，再让其成为现任主节点的从节点

5. RabbitMQ我应该记住的东西

   1. 消费者默认手动确认，自动确认话消息会消失，如果出现了故障不会回滚

   2. 发送方确认模式（确认消息到达了交换机）和失败回调（在**消息从交换机到达队列**的时候，如果失败了会调用一个失败回调方法）（都在发送方配置，rabbitTempalte回调，发送时回调）

   3. 发送方确认模式一般也会和失败回调一起使用 这样 就能确保消息100%投递了，也可以使用备用交换机，只要备用交换机有绑定队列就能保证消息投递成功。

   4. 消息预取

      以前是rabbitmq一股脑吧所有消息都均发给所有的消费者（不管你受不受得了） 而现在是在我消费者消费之前 先告诉rabbitmq **我一次能消费多少数据等我消费完了之后告诉rabbitmq**，rabbitmq再给我发送数据（个数500性能比较好，个数越少可靠性高，但是性能差）。

   5. **死信交换机**

   6. 防止消费者重复消费的方式是手动设定一个状态变量进行判断

   7. 普通集群下，节点之间会有对方的队列信息（配置信息），通过配置信息进行队列的定位

   8. 集群节点分内存和磁盘节点，一定要有一个磁盘节点，为了恢复数据

   9. 简单来说，镜像队列机制就是将队列在三个节点之间设置主从关系，消息会在三个节点之间进行自动同步，且如果其中一个节点不可用，并不会导致消息丢失或服务不可用的情况，提升MQ集群的整体高可用性。